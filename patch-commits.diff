diff --git a/cmd/commands/auth/login.go b/cmd/commands/auth/login.go
index d4e986a..d971599 100644
--- a/cmd/commands/auth/login.go
+++ b/cmd/commands/auth/login.go
@@ -1,12 +1,18 @@
 package auth
 
 import (
+	"bufio"
 	"fmt"
 	"os"
+	"slices"
 	"strings"
 
+	dnsproviders "nathanbeddoewebdev/vpsm/internal/dns/providers"
+	credproviders "nathanbeddoewebdev/vpsm/internal/platform/providers"
+	serverproviders "nathanbeddoewebdev/vpsm/internal/providers"
 	"nathanbeddoewebdev/vpsm/internal/services/auth"
 	"nathanbeddoewebdev/vpsm/internal/tui"
+	"nathanbeddoewebdev/vpsm/internal/util"
 
 	"github.com/spf13/cobra"
 	"golang.org/x/term"
@@ -15,11 +21,19 @@ import (
 func LoginCommand() *cobra.Command {
 	cmd := &cobra.Command{
 		Use:   "login <provider>",
-		Short: "Store an API token for a provider",
-		Long: `Store an API token for a provider using the local keychain.
+		Short: "Store credentials for a provider",
+		Long: `Store credentials for a provider using the local keychain.
 
-Example:
-  vpsm auth login hetzner`,
+For single-token providers (e.g. Hetzner, Cloudflare), you will be prompted for an API token.
+For multi-credential providers (e.g. Porkbun), you will be prompted for each key.
+
+Cloudflare requires a scoped Account API Token (not a Global API Key)
+with Zone:Read and DNS:Edit permissions.
+
+Examples:
+  vpsm auth login hetzner
+  vpsm auth login porkbun
+  vpsm auth login cloudflare`,
 		Args: cobra.ExactArgs(1),
 		Run: func(cmd *cobra.Command, args []string) {
 			provider := strings.TrimSpace(args[0])
@@ -28,14 +42,29 @@ Example:
 				return
 			}
 
+			if !isKnownProvider(provider) {
+				fmt.Fprintf(cmd.ErrOrStderr(), "Error: unknown provider %q\n", provider)
+				fmt.Fprintln(cmd.ErrOrStderr(), "Known providers: hetzner, porkbun, cloudflare")
+				return
+			}
+
+			store := auth.DefaultStore()
+			spec := credproviders.Lookup(provider)
+
+			// Multi-credential providers (e.g. Porkbun with apikey + secretapikey).
+			// These are always handled via stdin prompts regardless of TTY state
+			// because the TUI auth login only handles single-token providers.
+			if spec != nil && len(spec.Keys) > 1 {
+				runMultiKeyLogin(cmd, provider, spec, store)
+				return
+			}
+
 			token, err := cmd.Flags().GetString("token")
 			if err != nil {
 				fmt.Fprintln(cmd.ErrOrStderr(), err)
 				return
 			}
-
 			token = strings.TrimSpace(token)
-			store := auth.DefaultStore()
 
 			if token == "" {
 				// Interactive mode: use TUI if running in a terminal.
@@ -46,7 +75,7 @@ Example:
 						return
 					}
 					if result != nil && result.Saved {
-						fmt.Fprintf(cmd.OutOrStdout(), "Saved token for provider %s\n", provider)
+						fmt.Fprintf(cmd.OutOrStdout(), "Saved credentials for %s\n", provider)
 					} else {
 						fmt.Fprintln(cmd.ErrOrStderr(), "Login cancelled.")
 					}
@@ -57,21 +86,83 @@ Example:
 				return
 			}
 
-			if token == "" {
-				fmt.Fprintln(cmd.ErrOrStderr(), "token cannot be empty")
-				return
-			}
-
 			if err := store.SetToken(provider, token); err != nil {
 				fmt.Fprintln(cmd.ErrOrStderr(), err)
 				return
 			}
 
-			fmt.Fprintf(cmd.OutOrStdout(), "Saved token for provider %s\n", provider)
+			fmt.Fprintf(cmd.OutOrStdout(), "Saved credentials for %s\n", provider)
 		},
 	}
 
-	cmd.Flags().String("token", "", "API token (optional, overrides prompt)")
+	cmd.Flags().String("token", "", "API token (optional, overrides prompt; not used for multi-credential providers)")
 
 	return cmd
 }
+
+// runMultiKeyLogin handles the login flow for providers that require multiple
+// credentials (e.g. Porkbun API key + secret key). Each credential is prompted
+// for in sequence, reading from stdin with terminal echo suppressed for secrets.
+// isKnownProvider checks if a provider name is registered in any of the known
+// provider registries (credential specs, server providers, or DNS providers).
+func isKnownProvider(name string) bool {
+	normalized := util.NormalizeKey(name)
+
+	// Check credential spec registry (covers Hetzner, Porkbun, Cloudflare).
+	if credproviders.Lookup(normalized) != nil {
+		return true
+	}
+
+	// Check server provider registry.
+	if slices.Contains(serverproviders.List(), normalized) {
+		return true
+	}
+
+	// Check DNS provider registry.
+	return slices.Contains(dnsproviders.List(), normalized)
+}
+
+func runMultiKeyLogin(cmd *cobra.Command, provider string, spec *credproviders.CredentialSpec, store auth.Store) {
+	fmt.Fprintf(cmd.OutOrStdout(), "Logging in to %s\n", spec.DisplayName)
+
+	reader := bufio.NewReader(os.Stdin)
+	isTTY := term.IsTerminal(int(os.Stdin.Fd()))
+
+	for _, key := range spec.Keys {
+		keychainKey := spec.KeychainKey(key)
+		fmt.Fprintf(cmd.OutOrStdout(), "%s: ", key.Prompt)
+
+		var value string
+		var err error
+
+		if key.Secret && isTTY {
+			// Suppress echo for secret fields in a real terminal.
+			raw, readErr := term.ReadPassword(int(os.Stdin.Fd()))
+			fmt.Fprintln(cmd.OutOrStdout()) // newline after the hidden input
+			if readErr != nil {
+				fmt.Fprintf(cmd.ErrOrStderr(), "Error reading %s: %v\n", key.Prompt, readErr)
+				return
+			}
+			value = strings.TrimSpace(string(raw))
+		} else {
+			value, err = reader.ReadString('\n')
+			if err != nil {
+				fmt.Fprintf(cmd.ErrOrStderr(), "Error reading %s: %v\n", key.Prompt, err)
+				return
+			}
+			value = strings.TrimSpace(value)
+		}
+
+		if value == "" {
+			fmt.Fprintf(cmd.ErrOrStderr(), "%s cannot be empty\n", key.Prompt)
+			return
+		}
+
+		if err := store.SetToken(keychainKey, value); err != nil {
+			fmt.Fprintf(cmd.ErrOrStderr(), "Error saving %s: %v\n", key.Prompt, err)
+			return
+		}
+	}
+
+	fmt.Fprintf(cmd.OutOrStdout(), "Saved credentials for %s\n", provider)
+}
diff --git a/cmd/commands/auth/status.go b/cmd/commands/auth/status.go
index c7b68b1..fe5698e 100644
--- a/cmd/commands/auth/status.go
+++ b/cmd/commands/auth/status.go
@@ -5,6 +5,7 @@ import (
 	"fmt"
 	"os"
 
+	credproviders "nathanbeddoewebdev/vpsm/internal/platform/providers"
 	"nathanbeddoewebdev/vpsm/internal/providers"
 	"nathanbeddoewebdev/vpsm/internal/services/auth"
 	"nathanbeddoewebdev/vpsm/internal/tui"
@@ -18,7 +19,7 @@ func StatusCommand() *cobra.Command {
 	cmd := &cobra.Command{
 		Use:   "status",
 		Short: "Show authentication status for providers",
-		Long: `Show which providers have stored API tokens.
+		Long: `Show which providers have stored credentials.
 
 Example:
   vpsm auth status`,
@@ -33,23 +34,41 @@ Example:
 				return
 			}
 
-			// Non-interactive fallback.
-			providerNames := providers.List()
+			// Non-interactive fallback: check all known credential specs first,
+			// then fall back to the server provider registry for any not covered.
+			shown := map[string]bool{}
 
-			if len(providerNames) == 0 {
-				fmt.Fprintln(cmd.OutOrStdout(), "No providers registered.")
-				return
+			for _, spec := range credproviders.All() {
+				shown[spec.Provider] = true
+				loggedIn := true
+				for _, key := range spec.Keys {
+					keychainKey := spec.KeychainKey(key)
+					_, err := store.GetToken(keychainKey)
+					if err != nil {
+						loggedIn = false
+						break
+					}
+				}
+				if loggedIn {
+					fmt.Fprintf(cmd.OutOrStdout(), "%s: logged in\n", spec.Provider)
+				} else {
+					fmt.Fprintf(cmd.OutOrStdout(), "%s: not logged in\n", spec.Provider)
+				}
 			}
 
-			for _, provider := range providerNames {
-				_, err := store.GetToken(provider)
+			// Also show any server providers not covered by the credential spec registry.
+			for _, providerName := range providers.List() {
+				if shown[providerName] {
+					continue
+				}
+				_, err := store.GetToken(providerName)
 				switch {
 				case err == nil:
-					fmt.Fprintf(cmd.OutOrStdout(), "%s: logged in\n", provider)
+					fmt.Fprintf(cmd.OutOrStdout(), "%s: logged in\n", providerName)
 				case errors.Is(err, auth.ErrTokenNotFound):
-					fmt.Fprintf(cmd.OutOrStdout(), "%s: not logged in\n", provider)
+					fmt.Fprintf(cmd.OutOrStdout(), "%s: not logged in\n", providerName)
 				default:
-					fmt.Fprintf(cmd.OutOrStdout(), "%s: error (%v)\n", provider, err)
+					fmt.Fprintf(cmd.OutOrStdout(), "%s: error (%v)\n", providerName, err)
 				}
 			}
 		},
diff --git a/cmd/commands/config/set.go b/cmd/commands/config/set.go
index 4a665ec..5f2a682 100644
--- a/cmd/commands/config/set.go
+++ b/cmd/commands/config/set.go
@@ -2,9 +2,11 @@ package config
 
 import (
 	"fmt"
+	"slices"
 	"strings"
 
 	"nathanbeddoewebdev/vpsm/internal/config"
+	dnsproviders "nathanbeddoewebdev/vpsm/internal/dns/providers"
 	"nathanbeddoewebdev/vpsm/internal/providers"
 	"nathanbeddoewebdev/vpsm/internal/util"
 
@@ -31,6 +33,7 @@ func SetCommand() *cobra.Command {
 // Keys not present in this map have no extra validation.
 var validators = map[string]func(cmd *cobra.Command, value string) error{
 	"default-provider": validateProvider,
+	"dns-provider":     validateDNSProvider,
 }
 
 func runSet(cmd *cobra.Command, args []string) {
@@ -66,16 +69,26 @@ func runSet(cmd *cobra.Command, args []string) {
 	fmt.Fprintf(cmd.OutOrStdout(), "%s set to %q\n", spec.Name, normalized)
 }
 
-// validateProvider checks that the given name is a registered provider.
+// validateProvider checks that the given name is a registered server provider.
 func validateProvider(cmd *cobra.Command, name string) error {
 	normalized := util.NormalizeKey(name)
 	known := providers.List()
-	for _, p := range known {
-		if p == normalized {
-			return nil
-		}
+	if slices.Contains(known, normalized) {
+		return nil
 	}
 	fmt.Fprintf(cmd.ErrOrStderr(), "Error: unknown provider %q\n", name)
 	fmt.Fprintf(cmd.ErrOrStderr(), "Registered providers: %v\n", known)
 	return fmt.Errorf("unknown provider %q", name)
 }
+
+// validateDNSProvider checks that the given name is a registered DNS provider.
+func validateDNSProvider(cmd *cobra.Command, name string) error {
+	normalized := util.NormalizeKey(name)
+	known := dnsproviders.List()
+	if slices.Contains(known, normalized) {
+		return nil
+	}
+	fmt.Fprintf(cmd.ErrOrStderr(), "Error: unknown DNS provider %q\n", name)
+	fmt.Fprintf(cmd.ErrOrStderr(), "Registered DNS providers: %v\n", known)
+	return fmt.Errorf("unknown DNS provider %q", name)
+}
diff --git a/cmd/commands/dns/create.go b/cmd/commands/dns/create.go
new file mode 100644
index 0000000..f87ff05
--- /dev/null
+++ b/cmd/commands/dns/create.go
@@ -0,0 +1,69 @@
+package dns
+
+import (
+	"context"
+	"fmt"
+
+	dnsdomain "nathanbeddoewebdev/vpsm/internal/dns/domain"
+
+	"github.com/spf13/cobra"
+)
+
+// CreateCommand returns the "dns create" subcommand.
+func CreateCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:   "create <domain>",
+		Short: "Create a DNS record",
+		Long: `Create a new DNS record for the given domain.
+
+Examples:
+  vpsm dns create example.com --type A --name www --content 1.2.3.4
+  vpsm dns create example.com --type MX --content mail.example.com --priority 10
+  vpsm dns create example.com --type TXT --name _dmarc --content "v=DMARC1; p=none"`,
+		Args: cobra.ExactArgs(1),
+		Run:  runCreate,
+	}
+
+	cmd.Flags().String("type", "", "Record type (A, AAAA, CNAME, MX, TXT, etc.) [required]")
+	cmd.Flags().String("name", "", "Subdomain name (leave empty for root domain, use * for wildcard)")
+	cmd.Flags().String("content", "", "Record content (IP address, hostname, text value, etc.) [required]")
+	cmd.Flags().Int("ttl", 0, "Time-to-live in seconds (default: 600)")
+	cmd.Flags().Int("priority", 0, "Record priority (for MX, SRV, etc.)")
+	cmd.Flags().String("notes", "", "Optional notes for the record")
+
+	cmd.MarkFlagRequired("type")
+	cmd.MarkFlagRequired("content")
+
+	return cmd
+}
+
+func runCreate(cmd *cobra.Command, args []string) {
+	domainName := args[0]
+	recordType, _ := cmd.Flags().GetString("type")
+	name, _ := cmd.Flags().GetString("name")
+	content, _ := cmd.Flags().GetString("content")
+	ttl, _ := cmd.Flags().GetInt("ttl")
+	priority, _ := cmd.Flags().GetInt("priority")
+	notes, _ := cmd.Flags().GetString("notes")
+
+	svc, err := newDNSService(cmd)
+	if err != nil {
+		fmt.Fprintf(cmd.ErrOrStderr(), "Error: %v\n", err)
+		return
+	}
+	rec, err := svc.CreateRecord(context.Background(), domainName, dnsdomain.CreateRecordOpts{
+		Name:     name,
+		Type:     dnsdomain.RecordType(recordType),
+		Content:  content,
+		TTL:      ttl,
+		Priority: priority,
+		Notes:    notes,
+	})
+	if err != nil {
+		fmt.Fprintf(cmd.ErrOrStderr(), "Error creating record: %v\n", err)
+		return
+	}
+
+	fmt.Fprintf(cmd.OutOrStdout(), "Created record %s (%s %s -> %s)\n",
+		rec.ID, rec.Type, rec.Name, rec.Content)
+}
diff --git a/cmd/commands/dns/delete.go b/cmd/commands/dns/delete.go
new file mode 100644
index 0000000..761a83f
--- /dev/null
+++ b/cmd/commands/dns/delete.go
@@ -0,0 +1,38 @@
+package dns
+
+import (
+	"context"
+	"fmt"
+
+	"github.com/spf13/cobra"
+)
+
+// DeleteCommand returns the "dns delete" subcommand.
+func DeleteCommand() *cobra.Command {
+	return &cobra.Command{
+		Use:   "delete <domain> <id>",
+		Short: "Delete a DNS record",
+		Long: `Delete a DNS record by its ID.
+
+Example:
+  vpsm dns delete example.com 106926659`,
+		Args: cobra.ExactArgs(2),
+		Run:  runDelete,
+	}
+}
+
+func runDelete(cmd *cobra.Command, args []string) {
+	domainName := args[0]
+	recordID := args[1]
+	svc, err := newDNSService(cmd)
+	if err != nil {
+		fmt.Fprintf(cmd.ErrOrStderr(), "Error: %v\n", err)
+		return
+	}
+	if err := svc.DeleteRecord(context.Background(), domainName, recordID); err != nil {
+		fmt.Fprintf(cmd.ErrOrStderr(), "Error deleting record: %v\n", err)
+		return
+	}
+
+	fmt.Fprintf(cmd.OutOrStdout(), "Deleted record %s\n", recordID)
+}
diff --git a/cmd/commands/dns/dns.go b/cmd/commands/dns/dns.go
new file mode 100644
index 0000000..21edbcb
--- /dev/null
+++ b/cmd/commands/dns/dns.go
@@ -0,0 +1,71 @@
+package dns
+
+import (
+	"fmt"
+	"os"
+
+	"nathanbeddoewebdev/vpsm/internal/config"
+	dnsproviders "nathanbeddoewebdev/vpsm/internal/dns/providers"
+	"nathanbeddoewebdev/vpsm/internal/dns/services"
+	"nathanbeddoewebdev/vpsm/internal/services/auth"
+	"nathanbeddoewebdev/vpsm/internal/swrcache"
+
+	"github.com/spf13/cobra"
+)
+
+// NewCommand returns the top-level "dns" Cobra command with all subcommands attached.
+func NewCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:               "dns",
+		Short:             "Manage DNS records across providers",
+		Long:              `Create, list, update, and delete DNS records. List domains in your account.`,
+		PersistentPreRunE: resolveDNSProvider,
+	}
+
+	cmd.AddCommand(DomainsCommand())
+	cmd.AddCommand(ListCommand())
+	cmd.AddCommand(CreateCommand())
+	cmd.AddCommand(UpdateCommand())
+	cmd.AddCommand(DeleteCommand())
+
+	cmd.PersistentFlags().String("provider", "", "DNS provider to use (overrides default)")
+
+	return cmd
+}
+
+// resolveDNSProvider ensures the --provider flag has a value, falling back to
+// the dns-provider config key when the flag was not explicitly set.
+func resolveDNSProvider(cmd *cobra.Command, args []string) error {
+	if cmd.Flag("provider").Changed {
+		return nil
+	}
+
+	cfg, err := config.Load()
+	if err != nil {
+		return fmt.Errorf("failed to load config: %w", err)
+	}
+
+	if cfg.DNSProvider != "" {
+		if err := cmd.Flag("provider").Value.Set(cfg.DNSProvider); err != nil {
+			return fmt.Errorf("failed to set provider flag: %w", err)
+		}
+		return nil
+	}
+
+	return fmt.Errorf("no DNS provider specified: use --provider flag or set a default with 'vpsm config set dns-provider <name>'")
+}
+
+func newDNSService(cmd *cobra.Command) (*services.Service, error) {
+	providerName := cmd.Flag("provider").Value.String()
+	provider, err := dnsproviders.Get(providerName, auth.DefaultStore())
+	if err != nil {
+		return nil, err
+	}
+
+	if os.Getenv("VPSM_DISABLE_DNS_CACHE") == "1" {
+		return services.New(provider), nil
+	}
+
+	cache := swrcache.NewDefault()
+	return services.New(provider, services.WithCache(cache)), nil
+}
diff --git a/cmd/commands/dns/dns_test.go b/cmd/commands/dns/dns_test.go
new file mode 100644
index 0000000..609a302
--- /dev/null
+++ b/cmd/commands/dns/dns_test.go
@@ -0,0 +1,350 @@
+package dns
+
+import (
+	"bytes"
+	"context"
+	"fmt"
+	"strings"
+	"testing"
+
+	dnsdomain "nathanbeddoewebdev/vpsm/internal/dns/domain"
+	dnsproviders "nathanbeddoewebdev/vpsm/internal/dns/providers"
+	"nathanbeddoewebdev/vpsm/internal/services/auth"
+)
+
+// --- Mock DNS provider ---
+
+type mockDNSProvider struct {
+	displayName   string
+	domains       []dnsdomain.Domain
+	records       []dnsdomain.Record
+	createdRecord *dnsdomain.Record
+
+	listDomainsErr error
+	listRecordsErr error
+	createErr      error
+	updateErr      error
+	deleteErr      error
+
+	lastCreateOpts dnsdomain.CreateRecordOpts
+	lastUpdateID   string
+	lastDeleteID   string
+}
+
+func (m *mockDNSProvider) GetDisplayName() string { return m.displayName }
+
+func (m *mockDNSProvider) ListDomains(_ context.Context) ([]dnsdomain.Domain, error) {
+	return m.domains, m.listDomainsErr
+}
+
+func (m *mockDNSProvider) ListRecords(_ context.Context, _ string) ([]dnsdomain.Record, error) {
+	return m.records, m.listRecordsErr
+}
+
+func (m *mockDNSProvider) GetRecord(_ context.Context, domain string, id string) (*dnsdomain.Record, error) {
+	for _, r := range m.records {
+		if r.ID == id {
+			return &r, nil
+		}
+	}
+	return nil, dnsdomain.ErrNotFound
+}
+
+func (m *mockDNSProvider) CreateRecord(_ context.Context, domain string, opts dnsdomain.CreateRecordOpts) (*dnsdomain.Record, error) {
+	m.lastCreateOpts = opts
+	if m.createErr != nil {
+		return nil, m.createErr
+	}
+	if m.createdRecord != nil {
+		return m.createdRecord, nil
+	}
+	rec := &dnsdomain.Record{
+		ID:      "new-id",
+		Domain:  domain,
+		Type:    opts.Type,
+		Content: opts.Content,
+	}
+	return rec, nil
+}
+
+func (m *mockDNSProvider) UpdateRecord(_ context.Context, _ string, id string, _ dnsdomain.UpdateRecordOpts) error {
+	m.lastUpdateID = id
+	return m.updateErr
+}
+
+func (m *mockDNSProvider) DeleteRecord(_ context.Context, _ string, id string) error {
+	m.lastDeleteID = id
+	return m.deleteErr
+}
+
+// registerMockDNSProvider resets the DNS registry and registers a mock provider factory.
+func registerMockDNSProvider(t *testing.T, name string, mock *mockDNSProvider) {
+	t.Helper()
+	dnsproviders.Reset()
+	t.Cleanup(dnsproviders.Reset)
+	dnsproviders.Register(name, func(store auth.Store) (dnsdomain.Provider, error) {
+		return mock, nil
+	})
+}
+
+// execDNS runs the given dns subcommand args and returns stdout/stderr.
+func execDNS(t *testing.T, args ...string) (stdout, stderr string) {
+	t.Helper()
+	t.Setenv("VPSM_DISABLE_DNS_CACHE", "1")
+	var outBuf, errBuf bytes.Buffer
+	cmd := NewCommand()
+	cmd.SetOut(&outBuf)
+	cmd.SetErr(&errBuf)
+	cmd.SetArgs(args)
+	cmd.Execute()
+	return outBuf.String(), errBuf.String()
+}
+
+// --- domains tests ---
+
+func TestDomainsCommand_ListsDomains(t *testing.T) {
+	mock := &mockDNSProvider{
+		displayName: "Mock",
+		domains: []dnsdomain.Domain{
+			{Name: "example.com", Status: "ACTIVE", TLD: "com", ExpireDate: "2025-01-01 00:00:00"},
+			{Name: "mysite.io", Status: "ACTIVE", TLD: "io", ExpireDate: "2026-06-01 00:00:00"},
+		},
+	}
+	registerMockDNSProvider(t, "mock", mock)
+
+	stdout, stderr := execDNS(t, "domains", "--provider", "mock")
+	if stderr != "" {
+		t.Errorf("unexpected stderr: %s", stderr)
+	}
+
+	for _, want := range []string{"example.com", "mysite.io", "ACTIVE", "DOMAIN", "STATUS"} {
+		if !contains(stdout, want) {
+			t.Errorf("expected %q in output:\n%s", want, stdout)
+		}
+	}
+}
+
+func TestDomainsCommand_EmptyList(t *testing.T) {
+	mock := &mockDNSProvider{displayName: "Mock"}
+	registerMockDNSProvider(t, "mock", mock)
+
+	stdout, _ := execDNS(t, "domains", "--provider", "mock")
+	if !contains(stdout, "No domains found") {
+		t.Errorf("expected 'No domains found' in output:\n%s", stdout)
+	}
+}
+
+func TestDomainsCommand_ProviderError(t *testing.T) {
+	mock := &mockDNSProvider{listDomainsErr: fmt.Errorf("api error")}
+	registerMockDNSProvider(t, "mock", mock)
+
+	_, stderr := execDNS(t, "domains", "--provider", "mock")
+	if !contains(stderr, "api error") {
+		t.Errorf("expected 'api error' in stderr:\n%s", stderr)
+	}
+}
+
+// --- list tests ---
+
+func TestListCommand_ListsRecords(t *testing.T) {
+	mock := &mockDNSProvider{
+		displayName: "Mock",
+		records: []dnsdomain.Record{
+			{ID: "101", Domain: "example.com", Name: "example.com", Type: dnsdomain.RecordTypeA, Content: "1.2.3.4", TTL: 600},
+			{ID: "102", Domain: "example.com", Name: "www.example.com", Type: dnsdomain.RecordTypeCNAME, Content: "example.com", TTL: 600},
+		},
+	}
+	registerMockDNSProvider(t, "mock", mock)
+
+	stdout, stderr := execDNS(t, "list", "example.com", "--provider", "mock")
+	if stderr != "" {
+		t.Errorf("unexpected stderr: %s", stderr)
+	}
+
+	for _, want := range []string{"101", "102", "1.2.3.4", "CNAME", "ID", "NAME", "TYPE"} {
+		if !contains(stdout, want) {
+			t.Errorf("expected %q in output:\n%s", want, stdout)
+		}
+	}
+}
+
+func TestListCommand_EmptyList(t *testing.T) {
+	mock := &mockDNSProvider{displayName: "Mock"}
+	registerMockDNSProvider(t, "mock", mock)
+
+	stdout, _ := execDNS(t, "list", "example.com", "--provider", "mock")
+	if !contains(stdout, "No records found") {
+		t.Errorf("expected 'No records found' in output:\n%s", stdout)
+	}
+}
+
+func TestListCommand_FilterByType(t *testing.T) {
+	mock := &mockDNSProvider{
+		displayName: "Mock",
+		records: []dnsdomain.Record{
+			{ID: "101", Type: dnsdomain.RecordTypeA, Content: "1.2.3.4"},
+			{ID: "102", Type: dnsdomain.RecordTypeMX, Content: "mail.example.com"},
+		},
+	}
+	registerMockDNSProvider(t, "mock", mock)
+
+	// Test uppercase filter
+	stdout, _ := execDNS(t, "list", "example.com", "--provider", "mock", "--type", "A")
+	if !contains(stdout, "101") {
+		t.Errorf("expected record 101 in output:\n%s", stdout)
+	}
+	if contains(stdout, "102") {
+		t.Errorf("expected record 102 to be filtered out:\n%s", stdout)
+	}
+
+	// Test lowercase filter
+	stdout, _ = execDNS(t, "list", "example.com", "--provider", "mock", "--type", "a")
+	if !contains(stdout, "101") {
+		t.Errorf("expected record 101 in output with lowercase filter:\n%s", stdout)
+	}
+	if contains(stdout, "102") {
+		t.Errorf("expected record 102 to be filtered out with lowercase filter:\n%s", stdout)
+	}
+}
+
+func TestListCommand_ProviderError(t *testing.T) {
+	mock := &mockDNSProvider{listRecordsErr: fmt.Errorf("network timeout")}
+	registerMockDNSProvider(t, "mock", mock)
+
+	_, stderr := execDNS(t, "list", "example.com", "--provider", "mock")
+	if !contains(stderr, "network timeout") {
+		t.Errorf("expected 'network timeout' in stderr:\n%s", stderr)
+	}
+}
+
+// --- create tests ---
+
+func TestCreateCommand_CreatesRecord(t *testing.T) {
+	mock := &mockDNSProvider{
+		displayName: "Mock",
+		createdRecord: &dnsdomain.Record{
+			ID:      "201",
+			Domain:  "example.com",
+			Name:    "www.example.com",
+			Type:    dnsdomain.RecordTypeA,
+			Content: "5.6.7.8",
+		},
+	}
+	registerMockDNSProvider(t, "mock", mock)
+
+	stdout, stderr := execDNS(t, "create", "example.com",
+		"--provider", "mock",
+		"--type", "A",
+		"--name", "www",
+		"--content", "5.6.7.8",
+	)
+	if stderr != "" {
+		t.Errorf("unexpected stderr: %s", stderr)
+	}
+	if !contains(stdout, "201") {
+		t.Errorf("expected record ID '201' in output:\n%s", stdout)
+	}
+}
+
+func TestCreateCommand_MissingRequiredFlags(t *testing.T) {
+	mock := &mockDNSProvider{displayName: "Mock"}
+	registerMockDNSProvider(t, "mock", mock)
+
+	// Missing --content
+	_, stderr := execDNS(t, "create", "example.com", "--provider", "mock", "--type", "A")
+	if !contains(stderr, "content") {
+		t.Errorf("expected 'content' flag error in stderr:\n%s", stderr)
+	}
+}
+
+func TestCreateCommand_ProviderError(t *testing.T) {
+	mock := &mockDNSProvider{createErr: fmt.Errorf("duplicate record")}
+	registerMockDNSProvider(t, "mock", mock)
+
+	_, stderr := execDNS(t, "create", "example.com",
+		"--provider", "mock",
+		"--type", "A",
+		"--content", "1.2.3.4",
+	)
+	if !contains(stderr, "duplicate record") {
+		t.Errorf("expected 'duplicate record' in stderr:\n%s", stderr)
+	}
+}
+
+// --- update tests ---
+
+func TestUpdateCommand_UpdatesRecord(t *testing.T) {
+	mock := &mockDNSProvider{displayName: "Mock"}
+	registerMockDNSProvider(t, "mock", mock)
+
+	stdout, stderr := execDNS(t, "update", "example.com", "101",
+		"--provider", "mock",
+		"--content", "9.9.9.9",
+	)
+	if stderr != "" {
+		t.Errorf("unexpected stderr: %s", stderr)
+	}
+	if !contains(stdout, "101") {
+		t.Errorf("expected record ID '101' in output:\n%s", stdout)
+	}
+	if mock.lastUpdateID != "101" {
+		t.Errorf("lastUpdateID = %q, want %q", mock.lastUpdateID, "101")
+	}
+}
+
+func TestUpdateCommand_ProviderError(t *testing.T) {
+	mock := &mockDNSProvider{updateErr: fmt.Errorf("record not found")}
+	registerMockDNSProvider(t, "mock", mock)
+
+	_, stderr := execDNS(t, "update", "example.com", "999",
+		"--provider", "mock",
+		"--content", "1.1.1.1",
+	)
+	if !contains(stderr, "record not found") {
+		t.Errorf("expected 'record not found' in stderr:\n%s", stderr)
+	}
+}
+
+// --- delete tests ---
+
+func TestDeleteCommand_DeletesRecord(t *testing.T) {
+	mock := &mockDNSProvider{displayName: "Mock"}
+	registerMockDNSProvider(t, "mock", mock)
+
+	stdout, stderr := execDNS(t, "delete", "example.com", "101", "--provider", "mock")
+	if stderr != "" {
+		t.Errorf("unexpected stderr: %s", stderr)
+	}
+	if !contains(stdout, "101") {
+		t.Errorf("expected record ID '101' in output:\n%s", stdout)
+	}
+	if mock.lastDeleteID != "101" {
+		t.Errorf("lastDeleteID = %q, want %q", mock.lastDeleteID, "101")
+	}
+}
+
+func TestDeleteCommand_ProviderError(t *testing.T) {
+	mock := &mockDNSProvider{deleteErr: fmt.Errorf("record not found")}
+	registerMockDNSProvider(t, "mock", mock)
+
+	_, stderr := execDNS(t, "delete", "example.com", "999", "--provider", "mock")
+	if !contains(stderr, "record not found") {
+		t.Errorf("expected 'record not found' in stderr:\n%s", stderr)
+	}
+}
+
+func TestDeleteCommand_UnknownProvider(t *testing.T) {
+	dnsproviders.Reset()
+	t.Cleanup(dnsproviders.Reset)
+
+	_, stderr := execDNS(t, "delete", "example.com", "101", "--provider", "nonexistent")
+	if !contains(stderr, "unknown provider") {
+		t.Errorf("expected 'unknown provider' in stderr:\n%s", stderr)
+	}
+}
+
+// --- helpers ---
+
+func contains(s, substr string) bool {
+	return strings.Contains(s, substr)
+}
diff --git a/cmd/commands/dns/domains.go b/cmd/commands/dns/domains.go
new file mode 100644
index 0000000..9b84e06
--- /dev/null
+++ b/cmd/commands/dns/domains.go
@@ -0,0 +1,70 @@
+package dns
+
+import (
+	"context"
+	"fmt"
+	"os"
+	"text/tabwriter"
+
+	"nathanbeddoewebdev/vpsm/internal/tui"
+
+	"github.com/spf13/cobra"
+	"golang.org/x/term"
+)
+
+// DomainsCommand returns the "dns domains" subcommand.
+func DomainsCommand() *cobra.Command {
+	return &cobra.Command{
+		Use:   "domains",
+		Short: "List domains in the provider account",
+		Long: `List all domains registered in the DNS provider account.
+
+Example:
+  vpsm dns domains --provider porkbun`,
+		Args: cobra.NoArgs,
+		Run:  runDomains,
+	}
+}
+
+func runDomains(cmd *cobra.Command, args []string) {
+	svc, err := newDNSService(cmd)
+	if err != nil {
+		fmt.Fprintf(cmd.ErrOrStderr(), "Error: %v\n", err)
+		return
+	}
+
+	providerName := cmd.Flag("provider").Value.String()
+
+	if term.IsTerminal(int(os.Stdout.Fd())) {
+		if _, err := tui.RunDNSApp(svc, providerName, ""); err != nil {
+			fmt.Fprintf(cmd.ErrOrStderr(), "Error running TUI: %v\n", err)
+		}
+		return
+	}
+
+	domains, err := svc.ListDomains(context.Background())
+	if err != nil {
+		fmt.Fprintf(cmd.ErrOrStderr(), "Error listing domains: %v\n", err)
+		return
+	}
+
+	if len(domains) == 0 {
+		fmt.Fprintln(cmd.OutOrStdout(), "No domains found.")
+		return
+	}
+
+	w := tabwriter.NewWriter(cmd.OutOrStdout(), 0, 0, 3, ' ', 0)
+	fmt.Fprintln(w, "DOMAIN\tSTATUS\tTLD\tEXPIRES")
+	fmt.Fprintln(w, "------\t------\t---\t-------")
+
+	for _, d := range domains {
+		fmt.Fprintf(w, "%s\t%s\t%s\t%s\n",
+			d.Name,
+			d.Status,
+			d.TLD,
+			d.ExpireDate,
+		)
+	}
+
+	w.Flush()
+}
diff --git a/cmd/commands/dns/list.go b/cmd/commands/dns/list.go
new file mode 100644
index 0000000..2aac733
--- /dev/null
+++ b/cmd/commands/dns/list.go
@@ -0,0 +1,96 @@
+package dns
+
+import (
+	"context"
+	"fmt"
+	"os"
+	"strings"
+	"text/tabwriter"
+
+	"nathanbeddoewebdev/vpsm/internal/tui"
+
+	"github.com/spf13/cobra"
+	"golang.org/x/term"
+)
+
+// ListCommand returns the "dns list" subcommand.
+func ListCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:   "list <domain>",
+		Short: "List DNS records for a domain",
+		Long: `List all DNS records for the given domain.
+
+Examples:
+  vpsm dns list example.com
+  vpsm dns list example.com --type A`,
+		Args: cobra.ExactArgs(1),
+		Run:  runList,
+	}
+
+	cmd.Flags().String("type", "", "Filter records by type (A, AAAA, CNAME, MX, TXT, etc.)")
+
+	return cmd
+}
+
+func runList(cmd *cobra.Command, args []string) {
+	domainName := args[0]
+	typeFilter, _ := cmd.Flags().GetString("type")
+
+	svc, err := newDNSService(cmd)
+	if err != nil {
+		fmt.Fprintf(cmd.ErrOrStderr(), "Error: %v\n", err)
+		return
+	}
+
+	providerName := cmd.Flag("provider").Value.String()
+
+	if term.IsTerminal(int(os.Stdout.Fd())) {
+		if _, err := tui.RunDNSApp(svc, providerName, domainName); err != nil {
+			fmt.Fprintf(cmd.ErrOrStderr(), "Error running TUI: %v\n", err)
+		}
+		return
+	}
+
+	records, err := svc.ListRecords(context.Background(), domainName)
+	if err != nil {
+		fmt.Fprintf(cmd.ErrOrStderr(), "Error listing records: %v\n", err)
+		return
+	}
+
+	// Apply optional type filter.
+	if typeFilter != "" {
+		filtered := records[:0]
+		for _, r := range records {
+			if strings.EqualFold(string(r.Type), typeFilter) {
+				filtered = append(filtered, r)
+			}
+		}
+		records = filtered
+	}
+
+	if len(records) == 0 {
+		fmt.Fprintln(cmd.OutOrStdout(), "No records found.")
+		return
+	}
+
+	w := tabwriter.NewWriter(cmd.OutOrStdout(), 0, 0, 3, ' ', 0)
+	fmt.Fprintln(w, "ID\tNAME\tTYPE\tCONTENT\tTTL\tPRIORITY")
+	fmt.Fprintln(w, "--\t----\t----\t-------\t---\t--------")
+
+	for _, r := range records {
+		prio := ""
+		if r.Priority > 0 {
+			prio = fmt.Sprintf("%d", r.Priority)
+		}
+		fmt.Fprintf(w, "%s\t%s\t%s\t%s\t%d\t%s\n",
+			r.ID,
+			r.Name,
+			string(r.Type),
+			r.Content,
+			r.TTL,
+			prio,
+		)
+	}
+
+	w.Flush()
+}
diff --git a/cmd/commands/dns/update.go b/cmd/commands/dns/update.go
new file mode 100644
index 0000000..3920183
--- /dev/null
+++ b/cmd/commands/dns/update.go
@@ -0,0 +1,73 @@
+package dns
+
+import (
+	"context"
+	"fmt"
+
+	dnsdomain "nathanbeddoewebdev/vpsm/internal/dns/domain"
+
+	"github.com/spf13/cobra"
+)
+
+// UpdateCommand returns the "dns update" subcommand.
+func UpdateCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:   "update <domain> <id>",
+		Short: "Update a DNS record",
+		Long: `Update an existing DNS record by its ID.
+
+Examples:
+  vpsm dns update example.com 106926659 --content 5.6.7.8
+  vpsm dns update example.com 106926659 --content 5.6.7.8 --ttl 3600`,
+		Args: cobra.ExactArgs(2),
+		Run:  runUpdate,
+	}
+
+	cmd.Flags().String("type", "", "New record type")
+	cmd.Flags().String("name", "", "New subdomain name")
+	cmd.Flags().String("content", "", "New record content [required]")
+	cmd.Flags().Int("ttl", 0, "New time-to-live in seconds (default: 600)")
+	cmd.Flags().Int("priority", 0, "New record priority")
+	cmd.Flags().String("notes", "", "New notes (use empty string to clear)")
+
+	cmd.MarkFlagRequired("content")
+
+	return cmd
+}
+
+func runUpdate(cmd *cobra.Command, args []string) {
+	domainName := args[0]
+	recordID := args[1]
+	recordType, _ := cmd.Flags().GetString("type")
+	name, _ := cmd.Flags().GetString("name")
+	content, _ := cmd.Flags().GetString("content")
+	ttl, _ := cmd.Flags().GetInt("ttl")
+	priority, _ := cmd.Flags().GetInt("priority")
+
+	// Notes: nil means no change, pointer to empty string clears it.
+	var notesPtr *string
+	if cmd.Flags().Changed("notes") {
+		v, _ := cmd.Flags().GetString("notes")
+		notesPtr = &v
+	}
+
+	svc, err := newDNSService(cmd)
+	if err != nil {
+		fmt.Fprintf(cmd.ErrOrStderr(), "Error: %v\n", err)
+		return
+	}
+	err = svc.UpdateRecord(context.Background(), domainName, recordID, dnsdomain.UpdateRecordOpts{
+		Name:     name,
+		Type:     dnsdomain.RecordType(recordType),
+		Content:  content,
+		TTL:      ttl,
+		Priority: priority,
+		Notes:    notesPtr,
+	})
+	if err != nil {
+		fmt.Fprintf(cmd.ErrOrStderr(), "Error updating record: %v\n", err)
+		return
+	}
+
+	fmt.Fprintf(cmd.OutOrStdout(), "Updated record %s\n", recordID)
+}
diff --git a/cmd/commands/server/metrics_test.go b/cmd/commands/server/metrics_test.go
index 4e725d8..125ef35 100644
--- a/cmd/commands/server/metrics_test.go
+++ b/cmd/commands/server/metrics_test.go
@@ -5,6 +5,7 @@ import (
 	"context"
 	"encoding/json"
 	"fmt"
+	"slices"
 	"strings"
 	"testing"
 	"time"
@@ -219,13 +220,7 @@ func TestMetricsCommand_RequestsAllMetricTypes(t *testing.T) {
 		t.Errorf("expected %d metric types, got %d", len(expectedTypes), len(mock.gotTypes))
 	}
 	for _, want := range expectedTypes {
-		found := false
-		for _, got := range mock.gotTypes {
-			if got == want {
-				found = true
-				break
-			}
-		}
+		found := slices.Contains(mock.gotTypes, want)
 		if !found {
 			t.Errorf("expected metric type %q in request", want)
 		}
diff --git a/cmd/root.go b/cmd/root.go
index e8d083e..16c7401 100644
--- a/cmd/root.go
+++ b/cmd/root.go
@@ -5,8 +5,10 @@ import (
 
 	"nathanbeddoewebdev/vpsm/cmd/commands/auth"
 	cfgcmd "nathanbeddoewebdev/vpsm/cmd/commands/config"
+	"nathanbeddoewebdev/vpsm/cmd/commands/dns"
 	"nathanbeddoewebdev/vpsm/cmd/commands/server"
 	"nathanbeddoewebdev/vpsm/cmd/commands/sshkey"
+	dnsproviders "nathanbeddoewebdev/vpsm/internal/dns/providers"
 	"nathanbeddoewebdev/vpsm/internal/providers"
 
 	"github.com/spf13/cobra"
@@ -32,6 +34,7 @@ Quick start:
 
 	cmd.AddCommand(auth.NewCommand())
 	cmd.AddCommand(cfgcmd.NewCommand())
+	cmd.AddCommand(dns.NewCommand())
 	cmd.AddCommand(server.NewCommand())
 	cmd.AddCommand(sshkey.NewCommand())
 
@@ -42,6 +45,8 @@ Quick start:
 // This is called by main.main(). It only needs to happen once to the rootCmd.
 func Execute() {
 	providers.RegisterHetzner()
+	dnsproviders.RegisterPorkbun()
+	dnsproviders.RegisterCloudflare()
 
 	var root = rootCmd()
 	err := root.Execute()
diff --git a/internal/actionstore/repository_test.go b/internal/actionstore/repository_test.go
index 5c4ffb6..75c00ae 100644
--- a/internal/actionstore/repository_test.go
+++ b/internal/actionstore/repository_test.go
@@ -156,7 +156,7 @@ func TestListPending(t *testing.T) {
 func TestListRecent(t *testing.T) {
 	r := tempRepo(t)
 
-	for i := 0; i < 5; i++ {
+	for i := range 5 {
 		record := &ActionRecord{
 			Provider:  "hetzner",
 			ServerID:  "42",
@@ -184,7 +184,7 @@ func TestListRecent(t *testing.T) {
 func TestListRecent_All(t *testing.T) {
 	r := tempRepo(t)
 
-	for i := 0; i < 3; i++ {
+	for range 3 {
 		r.Save(&ActionRecord{Provider: "hetzner", ServerID: "42", Status: "success"})
 	}
 
diff --git a/internal/cache/cache.go b/internal/cache/cache.go
index f249e17..b77d431 100644
--- a/internal/cache/cache.go
+++ b/internal/cache/cache.go
@@ -24,7 +24,7 @@ func NewDefault() *Cache {
 }
 
 // Get returns true if a valid cache entry was found and decoded into dest.
-func (c *Cache) Get(key string, ttl time.Duration, dest interface{}) (bool, error) {
+func (c *Cache) Get(key string, ttl time.Duration, dest any) (bool, error) {
 	if c == nil || c.dir == "" || ttl <= 0 {
 		return false, nil
 	}
@@ -55,7 +55,7 @@ func (c *Cache) Get(key string, ttl time.Duration, dest interface{}) (bool, erro
 }
 
 // Set stores data in the cache under key.
-func (c *Cache) Set(key string, data interface{}) error {
+func (c *Cache) Set(key string, data any) error {
 	if c == nil || c.dir == "" {
 		return nil
 	}
diff --git a/internal/config/config.go b/internal/config/config.go
index 9ea3812..cd71ca5 100644
--- a/internal/config/config.go
+++ b/internal/config/config.go
@@ -31,6 +31,7 @@ func ResetPath() { pathOverride = "" }
 // Config holds user preferences that persist across invocations.
 type Config struct {
 	DefaultProvider string `json:"default_provider,omitempty"`
+	DNSProvider     string `json:"dns_provider,omitempty"`
 }
 
 // Path returns the absolute path to the config file.
diff --git a/internal/config/keys.go b/internal/config/keys.go
index 86f4ef3..a2fd0bd 100644
--- a/internal/config/keys.go
+++ b/internal/config/keys.go
@@ -30,6 +30,12 @@ var Keys = []KeySpec{
 		Get:         func(cfg *Config) string { return cfg.DefaultProvider },
 		Set:         func(cfg *Config, v string) { cfg.DefaultProvider = v },
 	},
+	{
+		Name:        "dns-provider",
+		Description: "DNS provider used when --provider is not specified for DNS commands",
+		Get:         func(cfg *Config) string { return cfg.DNSProvider },
+		Set:         func(cfg *Config, v string) { cfg.DNSProvider = v },
+	},
 }
 
 // Lookup returns the KeySpec for the given name, or nil if not found.
diff --git a/internal/dns/domain/create_opts.go b/internal/dns/domain/create_opts.go
new file mode 100644
index 0000000..f9b4434
--- /dev/null
+++ b/internal/dns/domain/create_opts.go
@@ -0,0 +1,49 @@
+package domain
+
+// CreateRecordOpts holds the parameters for creating a new DNS record.
+type CreateRecordOpts struct {
+	// Name is the subdomain portion of the record, not including the root domain.
+	// Leave empty to create a record on the root domain.
+	// Use "*" to create a wildcard record.
+	Name string
+
+	// Type is the DNS record type. Required.
+	Type RecordType
+
+	// Content is the record value. Required.
+	Content string
+
+	// TTL is the time-to-live in seconds.
+	// Zero means use the provider default (600 for Porkbun).
+	TTL int
+
+	// Priority is used for record types that support it (MX, SRV, etc.).
+	Priority int
+
+	// Notes is an optional human-readable annotation.
+	Notes string
+}
+
+// UpdateRecordOpts holds the parameters for updating an existing DNS record.
+// All fields are applied when provided.
+type UpdateRecordOpts struct {
+	// Name is the new subdomain portion. Leave empty to keep unchanged.
+	Name string
+
+	// Type is the new record type.
+	Type RecordType
+
+	// Content is the new record value. Required.
+	Content string
+
+	// TTL is the new time-to-live in seconds.
+	// Zero means use the provider default.
+	TTL int
+
+	// Priority is the new priority value.
+	Priority int
+
+	// Notes controls the record annotation.
+	// nil means no change; pointer to empty string clears the notes.
+	Notes *string
+}
diff --git a/internal/dns/domain/errors.go b/internal/dns/domain/errors.go
new file mode 100644
index 0000000..1281ae0
--- /dev/null
+++ b/internal/dns/domain/errors.go
@@ -0,0 +1,19 @@
+package domain
+
+import "nathanbeddoewebdev/vpsm/internal/domain"
+
+// Re-export shared sentinel errors so DNS callers do not need to import
+// the cross-domain package directly.
+var (
+	// ErrNotFound indicates the requested resource does not exist.
+	ErrNotFound = domain.ErrNotFound
+
+	// ErrUnauthorized indicates missing or invalid credentials.
+	ErrUnauthorized = domain.ErrUnauthorized
+
+	// ErrRateLimited indicates the provider throttled the request.
+	ErrRateLimited = domain.ErrRateLimited
+
+	// ErrConflict indicates a state or uniqueness conflict.
+	ErrConflict = domain.ErrConflict
+)
diff --git a/internal/dns/domain/provider.go b/internal/dns/domain/provider.go
new file mode 100644
index 0000000..8d8b8f5
--- /dev/null
+++ b/internal/dns/domain/provider.go
@@ -0,0 +1,28 @@
+package domain
+
+import "context"
+
+// Provider is the interface that DNS providers must implement.
+// It covers domain listing and full DNS record CRUD.
+type Provider interface {
+	// GetDisplayName returns the human-readable provider name (e.g. "Porkbun").
+	GetDisplayName() string
+
+	// ListDomains returns all domains registered in the provider account.
+	ListDomains(ctx context.Context) ([]Domain, error)
+
+	// ListRecords returns all DNS records for the given domain.
+	ListRecords(ctx context.Context, domain string) ([]Record, error)
+
+	// GetRecord returns a single DNS record by its ID.
+	GetRecord(ctx context.Context, domain string, id string) (*Record, error)
+
+	// CreateRecord creates a new DNS record and returns the created record.
+	CreateRecord(ctx context.Context, domain string, opts CreateRecordOpts) (*Record, error)
+
+	// UpdateRecord updates an existing DNS record by its ID.
+	UpdateRecord(ctx context.Context, domain string, id string, opts UpdateRecordOpts) error
+
+	// DeleteRecord deletes a DNS record by its ID.
+	DeleteRecord(ctx context.Context, domain string, id string) error
+}
diff --git a/internal/dns/domain/record.go b/internal/dns/domain/record.go
new file mode 100644
index 0000000..90cd34b
--- /dev/null
+++ b/internal/dns/domain/record.go
@@ -0,0 +1,67 @@
+package domain
+
+// RecordType represents a DNS record type.
+type RecordType string
+
+const (
+	RecordTypeA     RecordType = "A"
+	RecordTypeAAAA  RecordType = "AAAA"
+	RecordTypeCNAME RecordType = "CNAME"
+	RecordTypeAlias RecordType = "ALIAS"
+	RecordTypeTXT   RecordType = "TXT"
+	RecordTypeNS    RecordType = "NS"
+	RecordTypeMX    RecordType = "MX"
+	RecordTypeSRV   RecordType = "SRV"
+	RecordTypeTLSA  RecordType = "TLSA"
+	RecordTypeCAA   RecordType = "CAA"
+	RecordTypeHTTPS RecordType = "HTTPS"
+	RecordTypeSVCB  RecordType = "SVCB"
+	RecordTypeSSHFP RecordType = "SSHFP"
+)
+
+// Record represents a single DNS record.
+type Record struct {
+	// ID is the provider-assigned record identifier.
+	ID string `json:"id"`
+
+	// Domain is the root domain this record belongs to (e.g. "example.com").
+	Domain string `json:"domain"`
+
+	// Name is the fully-qualified record name as returned by the provider
+	// (e.g. "www.example.com" or "example.com" for a root record).
+	Name string `json:"name"`
+
+	// Type is the DNS record type (A, AAAA, CNAME, etc.).
+	Type RecordType `json:"type"`
+
+	// Content is the record value (IP address, hostname, text, etc.).
+	Content string `json:"content"`
+
+	// TTL is the time-to-live in seconds. The minimum is provider-dependent.
+	TTL int `json:"ttl"`
+
+	// Priority is used for record types that support it (MX, SRV, etc.).
+	// Zero means not applicable.
+	Priority int `json:"priority"`
+
+	// Notes is an optional human-readable annotation on the record.
+	Notes string `json:"notes"`
+}
+
+// Domain represents a domain name in the provider account.
+type Domain struct {
+	// Name is the registered domain name (e.g. "example.com").
+	Name string `json:"name"`
+
+	// Status is the current domain status (e.g. "ACTIVE").
+	Status string `json:"status"`
+
+	// TLD is the top-level domain suffix (e.g. "com").
+	TLD string `json:"tld"`
+
+	// CreateDate is when the domain was registered.
+	CreateDate string `json:"create_date"`
+
+	// ExpireDate is when the domain registration expires.
+	ExpireDate string `json:"expire_date"`
+}
diff --git a/internal/dns/providers/cloudflare.go b/internal/dns/providers/cloudflare.go
new file mode 100644
index 0000000..bc23a27
--- /dev/null
+++ b/internal/dns/providers/cloudflare.go
@@ -0,0 +1,467 @@
+package providers
+
+import (
+	"bytes"
+	"context"
+	"encoding/json"
+	"fmt"
+	"io"
+	"net/http"
+	"strings"
+	"time"
+
+	"nathanbeddoewebdev/vpsm/internal/dns/domain"
+	"nathanbeddoewebdev/vpsm/internal/services/auth"
+)
+
+const (
+	cloudflareBaseURL    = "https://api.cloudflare.com/client/v4"
+	cloudflareTimeout    = 30 * time.Second
+	cloudflareTokenStore = "cloudflare"
+)
+
+// Compile-time check that CloudflareProvider satisfies domain.Provider.
+var _ domain.Provider = (*CloudflareProvider)(nil)
+
+// CloudflareProvider implements domain.Provider using the Cloudflare API v4.
+// It authenticates via a scoped Account API Token (not a Global API Key).
+// The token needs Zone:Read and DNS:Edit permissions.
+// It uses a direct HTTP client rather than the official SDK to keep the
+// dependency tree light and the code consistent with other providers.
+type CloudflareProvider struct {
+	token   string
+	baseURL string
+	client  *http.Client
+}
+
+// NewCloudflareProvider creates a CloudflareProvider with the given Account API Token.
+func NewCloudflareProvider(token string) *CloudflareProvider {
+	return &CloudflareProvider{
+		token:   token,
+		baseURL: cloudflareBaseURL,
+		client:  &http.Client{Timeout: cloudflareTimeout},
+	}
+}
+
+// RegisterCloudflare registers the Cloudflare provider factory with the DNS registry.
+func RegisterCloudflare() {
+	Register("cloudflare", func(store auth.Store) (domain.Provider, error) {
+		token, err := store.GetToken(cloudflareTokenStore)
+		if err != nil {
+			return nil, fmt.Errorf("cloudflare auth: token not found (run 'vpsm auth login cloudflare'): %w", err)
+		}
+		return NewCloudflareProvider(token), nil
+	})
+}
+
+// GetDisplayName returns the human-readable provider name.
+func (c *CloudflareProvider) GetDisplayName() string {
+	return "Cloudflare"
+}
+
+// --- API request/response types ---
+
+// cfEnvelope is the standard Cloudflare API response wrapper.
+type cfEnvelope[T any] struct {
+	Success  bool      `json:"success"`
+	Errors   []cfError `json:"errors"`
+	Result   T         `json:"result"`
+	Messages []cfError `json:"messages,omitempty"`
+}
+
+// cfError represents a single Cloudflare API error.
+type cfError struct {
+	Code    int    `json:"code"`
+	Message string `json:"message"`
+}
+
+// cfResultInfo holds pagination info from Cloudflare list responses.
+type cfResultInfo struct {
+	Page       int `json:"page"`
+	PerPage    int `json:"per_page"`
+	TotalPages int `json:"total_pages"`
+	Count      int `json:"count"`
+	TotalCount int `json:"total_count"`
+}
+
+// cfListEnvelope extends the envelope with pagination info.
+type cfListEnvelope[T any] struct {
+	Success    bool         `json:"success"`
+	Errors     []cfError    `json:"errors"`
+	Result     []T          `json:"result"`
+	ResultInfo cfResultInfo `json:"result_info"`
+}
+
+// cfZone is the Cloudflare zone object.
+type cfZone struct {
+	ID        string `json:"id"`
+	Name      string `json:"name"`
+	Status    string `json:"status"`
+	CreatedOn string `json:"created_on"`
+}
+
+// cfDNSRecord is the Cloudflare DNS record object.
+type cfDNSRecord struct {
+	ID       string `json:"id"`
+	ZoneID   string `json:"zone_id"`
+	ZoneName string `json:"zone_name"`
+	Name     string `json:"name"`
+	Type     string `json:"type"`
+	Content  string `json:"content"`
+	TTL      int    `json:"ttl"`
+	Priority *int   `json:"priority,omitempty"`
+	Comment  string `json:"comment"`
+}
+
+// cfCreateRecordBody is the request body for creating a DNS record.
+type cfCreateRecordBody struct {
+	Type     string `json:"type"`
+	Name     string `json:"name"`
+	Content  string `json:"content"`
+	TTL      int    `json:"ttl,omitempty"`
+	Priority *int   `json:"priority,omitempty"`
+	Comment  string `json:"comment,omitempty"`
+}
+
+// cfUpdateRecordBody is the request body for updating (PATCH) a DNS record.
+type cfUpdateRecordBody struct {
+	Type     string  `json:"type"`
+	Name     string  `json:"name"`
+	Content  string  `json:"content"`
+	TTL      int     `json:"ttl,omitempty"`
+	Priority *int    `json:"priority,omitempty"`
+	Comment  *string `json:"comment,omitempty"`
+}
+
+// --- HTTP helpers ---
+
+// envelopeError extracts a single error from a Cloudflare response envelope.
+// It maps known HTTP-level and API-level error codes to domain sentinels.
+func envelopeError(success bool, errors []cfError, httpStatus int) error {
+	if success {
+		return nil
+	}
+
+	// Map HTTP status codes to domain sentinels.
+	switch httpStatus {
+	case http.StatusUnauthorized, http.StatusForbidden:
+		return fmt.Errorf("%w: %s", domain.ErrUnauthorized, cfErrorString(errors))
+	case http.StatusNotFound:
+		return fmt.Errorf("%w: %s", domain.ErrNotFound, cfErrorString(errors))
+	case http.StatusTooManyRequests:
+		return fmt.Errorf("%w: %s", domain.ErrRateLimited, cfErrorString(errors))
+	case http.StatusConflict:
+		return fmt.Errorf("%w: %s", domain.ErrConflict, cfErrorString(errors))
+	}
+
+	// Fall back to inspecting the error codes/messages.
+	for _, e := range errors {
+		msg := strings.ToLower(e.Message)
+		switch {
+		case e.Code == 9109 || e.Code == 10000 || strings.Contains(msg, "authentication"):
+			return fmt.Errorf("%w: %s", domain.ErrUnauthorized, e.Message)
+		case e.Code == 81044 || strings.Contains(msg, "not found"):
+			return fmt.Errorf("%w: %s", domain.ErrNotFound, e.Message)
+		case e.Code == 81057 || strings.Contains(msg, "already exists"):
+			return fmt.Errorf("%w: %s", domain.ErrConflict, e.Message)
+		}
+	}
+
+	return fmt.Errorf("cloudflare: %s", cfErrorString(errors))
+}
+
+// cfErrorString joins multiple Cloudflare errors into a single string.
+func cfErrorString(errors []cfError) string {
+	if len(errors) == 0 {
+		return "unknown error"
+	}
+	msgs := make([]string, 0, len(errors))
+	for _, e := range errors {
+		msgs = append(msgs, fmt.Sprintf("[%d] %s", e.Code, e.Message))
+	}
+	return strings.Join(msgs, "; ")
+}
+
+// doJSONWithStatus is like doJSON but also captures the HTTP status code
+// for use in error mapping.
+func (c *CloudflareProvider) doJSONWithStatus(ctx context.Context, method, path string, body any, out any) (int, error) {
+	var bodyReader io.Reader
+	if body != nil {
+		data, err := json.Marshal(body)
+		if err != nil {
+			return 0, fmt.Errorf("cloudflare: failed to encode request: %w", err)
+		}
+		bodyReader = bytes.NewReader(data)
+	}
+
+	req, err := http.NewRequestWithContext(ctx, method, c.baseURL+path, bodyReader)
+	if err != nil {
+		return 0, fmt.Errorf("cloudflare: failed to build request: %w", err)
+	}
+	req.Header.Set("Authorization", "Bearer "+c.token)
+	if body != nil {
+		req.Header.Set("Content-Type", "application/json")
+	}
+
+	resp, err := c.client.Do(req)
+	if err != nil {
+		return 0, fmt.Errorf("cloudflare: request failed: %w", err)
+	}
+	defer resp.Body.Close()
+
+	if err := json.NewDecoder(resp.Body).Decode(out); err != nil {
+		return resp.StatusCode, fmt.Errorf("cloudflare: failed to decode response: %w", err)
+	}
+
+	return resp.StatusCode, nil
+}
+
+// --- Zone lookup ---
+
+// getZoneID resolves a domain name to its Cloudflare zone ID.
+func (c *CloudflareProvider) getZoneID(ctx context.Context, domainName string) (string, error) {
+	var out cfListEnvelope[cfZone]
+	status, err := c.doJSONWithStatus(ctx, http.MethodGet, "/zones?name="+domainName+"&per_page=1", nil, &out)
+	if err != nil {
+		return "", fmt.Errorf("failed to look up zone for %q: %w", domainName, err)
+	}
+	if apiErr := envelopeError(out.Success, out.Errors, status); apiErr != nil {
+		return "", fmt.Errorf("failed to look up zone for %q: %w", domainName, apiErr)
+	}
+
+	if len(out.Result) == 0 {
+		return "", fmt.Errorf("zone for %q: %w", domainName, domain.ErrNotFound)
+	}
+
+	return out.Result[0].ID, nil
+}
+
+// --- Provider implementation ---
+
+// ListDomains returns all zones (domains) in the Cloudflare account.
+func (c *CloudflareProvider) ListDomains(ctx context.Context) ([]domain.Domain, error) {
+	var allZones []cfZone
+	page := 1
+
+	for {
+		path := fmt.Sprintf("/zones?page=%d&per_page=50", page)
+		var out cfListEnvelope[cfZone]
+		status, err := c.doJSONWithStatus(ctx, http.MethodGet, path, nil, &out)
+		if err != nil {
+			return nil, fmt.Errorf("failed to list domains: %w", err)
+		}
+		if apiErr := envelopeError(out.Success, out.Errors, status); apiErr != nil {
+			return nil, fmt.Errorf("failed to list domains: %w", apiErr)
+		}
+
+		allZones = append(allZones, out.Result...)
+
+		if page >= out.ResultInfo.TotalPages {
+			break
+		}
+		page++
+	}
+
+	domains := make([]domain.Domain, 0, len(allZones))
+	for _, z := range allZones {
+		domains = append(domains, domain.Domain{
+			Name:       z.Name,
+			Status:     z.Status,
+			TLD:        extractTLD(z.Name),
+			CreateDate: z.CreatedOn,
+			ExpireDate: "N/A",
+		})
+	}
+	return domains, nil
+}
+
+// ListRecords returns all DNS records for the given domain.
+func (c *CloudflareProvider) ListRecords(ctx context.Context, domainName string) ([]domain.Record, error) {
+	zoneID, err := c.getZoneID(ctx, domainName)
+	if err != nil {
+		return nil, err
+	}
+
+	var allRecords []cfDNSRecord
+	page := 1
+
+	for {
+		path := fmt.Sprintf("/zones/%s/dns_records?page=%d&per_page=100", zoneID, page)
+		var out cfListEnvelope[cfDNSRecord]
+		status, err := c.doJSONWithStatus(ctx, http.MethodGet, path, nil, &out)
+		if err != nil {
+			return nil, fmt.Errorf("failed to list records for %q: %w", domainName, err)
+		}
+		if apiErr := envelopeError(out.Success, out.Errors, status); apiErr != nil {
+			return nil, fmt.Errorf("failed to list records for %q: %w", domainName, apiErr)
+		}
+
+		allRecords = append(allRecords, out.Result...)
+
+		if page >= out.ResultInfo.TotalPages {
+			break
+		}
+		page++
+	}
+
+	records := make([]domain.Record, 0, len(allRecords))
+	for _, r := range allRecords {
+		records = append(records, cfToDomainRecord(domainName, r))
+	}
+	return records, nil
+}
+
+// GetRecord returns a single DNS record by its ID.
+func (c *CloudflareProvider) GetRecord(ctx context.Context, domainName string, id string) (*domain.Record, error) {
+	zoneID, err := c.getZoneID(ctx, domainName)
+	if err != nil {
+		return nil, err
+	}
+
+	path := fmt.Sprintf("/zones/%s/dns_records/%s", zoneID, id)
+	var out cfEnvelope[cfDNSRecord]
+	status, err := c.doJSONWithStatus(ctx, http.MethodGet, path, nil, &out)
+	if err != nil {
+		return nil, fmt.Errorf("failed to get record %q for %q: %w", id, domainName, err)
+	}
+	if apiErr := envelopeError(out.Success, out.Errors, status); apiErr != nil {
+		return nil, fmt.Errorf("failed to get record %q for %q: %w", id, domainName, apiErr)
+	}
+
+	rec := cfToDomainRecord(domainName, out.Result)
+	return &rec, nil
+}
+
+// CreateRecord creates a new DNS record and returns the created record.
+func (c *CloudflareProvider) CreateRecord(ctx context.Context, domainName string, opts domain.CreateRecordOpts) (*domain.Record, error) {
+	zoneID, err := c.getZoneID(ctx, domainName)
+	if err != nil {
+		return nil, err
+	}
+
+	// Build the FQDN name: subdomain.domain or just domain for root.
+	name := domainName
+	if opts.Name != "" {
+		name = opts.Name + "." + domainName
+	}
+
+	body := cfCreateRecordBody{
+		Type:    string(opts.Type),
+		Name:    name,
+		Content: opts.Content,
+		TTL:     opts.TTL,
+		Comment: opts.Notes,
+	}
+	if opts.Priority > 0 {
+		p := opts.Priority
+		body.Priority = &p
+	}
+
+	path := fmt.Sprintf("/zones/%s/dns_records", zoneID)
+	var out cfEnvelope[cfDNSRecord]
+	status, err := c.doJSONWithStatus(ctx, http.MethodPost, path, body, &out)
+	if err != nil {
+		return nil, fmt.Errorf("failed to create record for %q: %w", domainName, err)
+	}
+	if apiErr := envelopeError(out.Success, out.Errors, status); apiErr != nil {
+		return nil, fmt.Errorf("failed to create record for %q: %w", domainName, apiErr)
+	}
+
+	rec := cfToDomainRecord(domainName, out.Result)
+	return &rec, nil
+}
+
+// UpdateRecord updates an existing DNS record by its ID.
+func (c *CloudflareProvider) UpdateRecord(ctx context.Context, domainName string, id string, opts domain.UpdateRecordOpts) error {
+	zoneID, err := c.getZoneID(ctx, domainName)
+	if err != nil {
+		return err
+	}
+
+	// Build the FQDN name.
+	name := domainName
+	if opts.Name != "" {
+		name = opts.Name + "." + domainName
+	}
+
+	body := cfUpdateRecordBody{
+		Type:    string(opts.Type),
+		Name:    name,
+		Content: opts.Content,
+		TTL:     opts.TTL,
+	}
+	if opts.Priority > 0 {
+		p := opts.Priority
+		body.Priority = &p
+	}
+	if opts.Notes != nil {
+		body.Comment = opts.Notes
+	}
+
+	path := fmt.Sprintf("/zones/%s/dns_records/%s", zoneID, id)
+	var out cfEnvelope[cfDNSRecord]
+	status, err := c.doJSONWithStatus(ctx, http.MethodPatch, path, body, &out)
+	if err != nil {
+		return fmt.Errorf("failed to update record %q for %q: %w", id, domainName, err)
+	}
+	if apiErr := envelopeError(out.Success, out.Errors, status); apiErr != nil {
+		return fmt.Errorf("failed to update record %q for %q: %w", id, domainName, apiErr)
+	}
+
+	return nil
+}
+
+// DeleteRecord deletes a DNS record by its ID.
+func (c *CloudflareProvider) DeleteRecord(ctx context.Context, domainName string, id string) error {
+	zoneID, err := c.getZoneID(ctx, domainName)
+	if err != nil {
+		return err
+	}
+
+	path := fmt.Sprintf("/zones/%s/dns_records/%s", zoneID, id)
+	var out cfEnvelope[struct {
+		ID string `json:"id"`
+	}]
+	status, err := c.doJSONWithStatus(ctx, http.MethodDelete, path, nil, &out)
+	if err != nil {
+		return fmt.Errorf("failed to delete record %q for %q: %w", id, domainName, err)
+	}
+	if apiErr := envelopeError(out.Success, out.Errors, status); apiErr != nil {
+		return fmt.Errorf("failed to delete record %q for %q: %w", id, domainName, apiErr)
+	}
+
+	return nil
+}
+
+// --- Conversion helpers ---
+
+// extractTLD returns the top-level domain suffix from a domain name.
+// For "example.com" it returns "com"; for "example.co.uk" it returns "co.uk".
+// This is a simple heuristic based on the first dot  it does not handle
+// multi-part public suffixes (co.uk, com.au, etc.) precisely.
+func extractTLD(name string) string {
+	idx := strings.IndexByte(name, '.')
+	if idx < 0 || idx >= len(name)-1 {
+		return ""
+	}
+	return name[idx+1:]
+}
+
+// cfToDomainRecord converts a Cloudflare API record to a domain.Record.
+func cfToDomainRecord(domainName string, r cfDNSRecord) domain.Record {
+	prio := 0
+	if r.Priority != nil {
+		prio = *r.Priority
+	}
+
+	return domain.Record{
+		ID:       r.ID,
+		Domain:   domainName,
+		Name:     r.Name,
+		Type:     domain.RecordType(r.Type),
+		Content:  r.Content,
+		TTL:      r.TTL,
+		Priority: prio,
+		Notes:    r.Comment,
+	}
+}
diff --git a/internal/dns/providers/cloudflare_test.go b/internal/dns/providers/cloudflare_test.go
new file mode 100644
index 0000000..9e2606a
--- /dev/null
+++ b/internal/dns/providers/cloudflare_test.go
@@ -0,0 +1,660 @@
+package providers
+
+import (
+	"context"
+	"encoding/json"
+	"errors"
+	"fmt"
+	"net/http"
+	"net/http/httptest"
+	"strings"
+	"testing"
+
+	"nathanbeddoewebdev/vpsm/internal/dns/domain"
+	"nathanbeddoewebdev/vpsm/internal/services/auth"
+
+	"github.com/google/go-cmp/cmp"
+)
+
+// --- Test helpers ---
+
+// newTestCloudflareProvider creates a CloudflareProvider pointed at the given test server.
+func newTestCloudflareProvider(t *testing.T, serverURL string) *CloudflareProvider {
+	t.Helper()
+	p := NewCloudflareProvider("test-token")
+	p.baseURL = serverURL
+	return p
+}
+
+// cfSuccessEnvelope returns a Cloudflare success envelope wrapping the given result.
+func cfSuccessEnvelope(result any) map[string]any {
+	return map[string]any{
+		"success":  true,
+		"errors":   []any{},
+		"messages": []any{},
+		"result":   result,
+	}
+}
+
+// cfSuccessListEnvelope returns a Cloudflare success list envelope with pagination.
+func cfSuccessListEnvelope(result []any, page, totalPages, totalCount int) map[string]any {
+	return map[string]any{
+		"success":  true,
+		"errors":   []any{},
+		"messages": []any{},
+		"result":   result,
+		"result_info": map[string]any{
+			"page":        page,
+			"per_page":    50,
+			"total_pages": totalPages,
+			"count":       len(result),
+			"total_count": totalCount,
+		},
+	}
+}
+
+// cfErrorEnvelope returns a Cloudflare error envelope.
+func cfErrorEnvelope(code int, message string) map[string]any {
+	return map[string]any{
+		"success":  false,
+		"errors":   []any{map[string]any{"code": code, "message": message}},
+		"messages": []any{},
+		"result":   nil,
+	}
+}
+
+// testCFZoneJSON returns a sample Cloudflare zone object.
+func testCFZoneJSON(id, name, status string) map[string]any {
+	return map[string]any{
+		"id":         id,
+		"name":       name,
+		"status":     status,
+		"created_on": "2024-01-01T00:00:00.000000Z",
+	}
+}
+
+// testCFRecordJSON returns a sample Cloudflare DNS record object.
+func testCFRecordJSON(id, name, typ, content string, ttl int, priority *int, comment string) map[string]any {
+	rec := map[string]any{
+		"id":        id,
+		"zone_id":   "zone-123",
+		"zone_name": "example.com",
+		"name":      name,
+		"type":      typ,
+		"content":   content,
+		"ttl":       ttl,
+		"comment":   comment,
+	}
+	if priority != nil {
+		rec["priority"] = *priority
+	}
+	return rec
+}
+
+// intPtr is a helper to create an *int.
+//
+//go:fix inline
+func intPtr(v int) *int { return new(v) }
+
+// newCFRouter creates a httptest.Server that routes requests based on method + path.
+// The handler map keys are "METHOD /path" strings.
+func newCFRouter(t *testing.T, handlers map[string]http.HandlerFunc) *httptest.Server {
+	t.Helper()
+	srv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+		// Strip query string for matching.
+		pathWithQuery := r.URL.Path
+		key := r.Method + " " + pathWithQuery
+
+		// Try exact match first, then with query.
+		handler, ok := handlers[key]
+		if !ok {
+			// Try matching with the full URL (method + path + query).
+			key = r.Method + " " + r.URL.String()
+			handler, ok = handlers[key]
+		}
+		if !ok {
+			// Try matching method + path exactly (ignoring query).
+			for k, h := range handlers {
+				parts := strings.SplitN(k, " ", 2)
+				if len(parts) == 2 && parts[0] == r.Method && parts[1] == r.URL.Path {
+					handler = h
+					ok = true
+					break
+				}
+			}
+		}
+		if !ok {
+			w.WriteHeader(http.StatusNotFound)
+			json.NewEncoder(w).Encode(cfErrorEnvelope(0, fmt.Sprintf("no handler for %s %s", r.Method, r.URL.String())))
+			return
+		}
+		handler(w, r)
+	}))
+	t.Cleanup(srv.Close)
+	return srv
+}
+
+// --- ListDomains tests ---
+
+func TestCloudflare_ListDomains_HappyPath(t *testing.T) {
+	srv := newCFRouter(t, map[string]http.HandlerFunc{
+		"GET /zones": func(w http.ResponseWriter, r *http.Request) {
+			body := cfSuccessListEnvelope([]any{
+				testCFZoneJSON("zone-1", "example.com", "active"),
+				testCFZoneJSON("zone-2", "another.io", "active"),
+			}, 1, 1, 2)
+			w.Header().Set("Content-Type", "application/json")
+			json.NewEncoder(w).Encode(body)
+		},
+	})
+
+	p := newTestCloudflareProvider(t, srv.URL)
+
+	domains, err := p.ListDomains(context.Background())
+	if err != nil {
+		t.Fatalf("expected no error, got %v", err)
+	}
+
+	want := []domain.Domain{
+		{Name: "example.com", Status: "active", TLD: "com", CreateDate: "2024-01-01T00:00:00.000000Z", ExpireDate: "N/A"},
+		{Name: "another.io", Status: "active", TLD: "io", CreateDate: "2024-01-01T00:00:00.000000Z", ExpireDate: "N/A"},
+	}
+
+	if diff := cmp.Diff(want, domains); diff != "" {
+		t.Errorf("ListDomains mismatch (-want +got):\n%s", diff)
+	}
+}
+
+func TestCloudflare_ListDomains_Pagination(t *testing.T) {
+	callCount := 0
+	srv := newCFRouter(t, map[string]http.HandlerFunc{
+		"GET /zones": func(w http.ResponseWriter, r *http.Request) {
+			callCount++
+			w.Header().Set("Content-Type", "application/json")
+			if callCount == 1 {
+				body := cfSuccessListEnvelope([]any{
+					testCFZoneJSON("zone-1", "example.com", "active"),
+				}, 1, 2, 2)
+				json.NewEncoder(w).Encode(body)
+			} else {
+				body := cfSuccessListEnvelope([]any{
+					testCFZoneJSON("zone-2", "another.io", "active"),
+				}, 2, 2, 2)
+				json.NewEncoder(w).Encode(body)
+			}
+		},
+	})
+
+	p := newTestCloudflareProvider(t, srv.URL)
+
+	domains, err := p.ListDomains(context.Background())
+	if err != nil {
+		t.Fatalf("expected no error, got %v", err)
+	}
+	if len(domains) != 2 {
+		t.Fatalf("expected 2 domains, got %d", len(domains))
+	}
+	if callCount != 2 {
+		t.Errorf("expected 2 API calls for pagination, got %d", callCount)
+	}
+}
+
+func TestCloudflare_ListDomains_EmptyList(t *testing.T) {
+	srv := newCFRouter(t, map[string]http.HandlerFunc{
+		"GET /zones": func(w http.ResponseWriter, r *http.Request) {
+			body := cfSuccessListEnvelope([]any{}, 1, 1, 0)
+			w.Header().Set("Content-Type", "application/json")
+			json.NewEncoder(w).Encode(body)
+		},
+	})
+
+	p := newTestCloudflareProvider(t, srv.URL)
+
+	domains, err := p.ListDomains(context.Background())
+	if err != nil {
+		t.Fatalf("expected no error, got %v", err)
+	}
+	if len(domains) != 0 {
+		t.Errorf("expected 0 domains, got %d", len(domains))
+	}
+}
+
+func TestCloudflare_ListDomains_Unauthorized(t *testing.T) {
+	srv := newCFRouter(t, map[string]http.HandlerFunc{
+		"GET /zones": func(w http.ResponseWriter, r *http.Request) {
+			w.Header().Set("Content-Type", "application/json")
+			w.WriteHeader(http.StatusUnauthorized)
+			json.NewEncoder(w).Encode(cfErrorEnvelope(9109, "Invalid access token"))
+		},
+	})
+
+	p := newTestCloudflareProvider(t, srv.URL)
+
+	_, err := p.ListDomains(context.Background())
+	if err == nil {
+		t.Fatal("expected error, got nil")
+	}
+	if !errors.Is(err, domain.ErrUnauthorized) {
+		t.Errorf("expected ErrUnauthorized, got: %v", err)
+	}
+}
+
+// --- ListRecords tests ---
+
+func TestCloudflare_ListRecords_HappyPath(t *testing.T) {
+	srv := newCFRouter(t, map[string]http.HandlerFunc{
+		"GET /zones": func(w http.ResponseWriter, r *http.Request) {
+			w.Header().Set("Content-Type", "application/json")
+			json.NewEncoder(w).Encode(cfSuccessListEnvelope([]any{
+				testCFZoneJSON("zone-123", "example.com", "active"),
+			}, 1, 1, 1))
+		},
+		"GET /zones/zone-123/dns_records": func(w http.ResponseWriter, r *http.Request) {
+			w.Header().Set("Content-Type", "application/json")
+			json.NewEncoder(w).Encode(cfSuccessListEnvelope([]any{
+				testCFRecordJSON("rec-1", "example.com", "A", "1.2.3.4", 300, nil, ""),
+				testCFRecordJSON("rec-2", "www.example.com", "A", "1.2.3.4", 300, nil, ""),
+				testCFRecordJSON("rec-3", "example.com", "MX", "mail.example.com", 3600, new(10), "mail server"),
+			}, 1, 1, 3))
+		},
+	})
+
+	p := newTestCloudflareProvider(t, srv.URL)
+
+	records, err := p.ListRecords(context.Background(), "example.com")
+	if err != nil {
+		t.Fatalf("expected no error, got %v", err)
+	}
+	if len(records) != 3 {
+		t.Fatalf("expected 3 records, got %d", len(records))
+	}
+
+	if records[0].ID != "rec-1" {
+		t.Errorf("records[0].ID = %q, want %q", records[0].ID, "rec-1")
+	}
+	if records[0].TTL != 300 {
+		t.Errorf("records[0].TTL = %d, want 300", records[0].TTL)
+	}
+	if records[2].Priority != 10 {
+		t.Errorf("records[2].Priority = %d, want 10", records[2].Priority)
+	}
+	if records[2].Notes != "mail server" {
+		t.Errorf("records[2].Notes = %q, want %q", records[2].Notes, "mail server")
+	}
+}
+
+func TestCloudflare_ListRecords_ZoneNotFound(t *testing.T) {
+	srv := newCFRouter(t, map[string]http.HandlerFunc{
+		"GET /zones": func(w http.ResponseWriter, r *http.Request) {
+			w.Header().Set("Content-Type", "application/json")
+			json.NewEncoder(w).Encode(cfSuccessListEnvelope([]any{}, 1, 1, 0))
+		},
+	})
+
+	p := newTestCloudflareProvider(t, srv.URL)
+
+	_, err := p.ListRecords(context.Background(), "notexist.com")
+	if err == nil {
+		t.Fatal("expected error, got nil")
+	}
+	if !errors.Is(err, domain.ErrNotFound) {
+		t.Errorf("expected ErrNotFound, got: %v", err)
+	}
+}
+
+// --- GetRecord tests ---
+
+func TestCloudflare_GetRecord_HappyPath(t *testing.T) {
+	srv := newCFRouter(t, map[string]http.HandlerFunc{
+		"GET /zones": func(w http.ResponseWriter, r *http.Request) {
+			w.Header().Set("Content-Type", "application/json")
+			json.NewEncoder(w).Encode(cfSuccessListEnvelope([]any{
+				testCFZoneJSON("zone-123", "example.com", "active"),
+			}, 1, 1, 1))
+		},
+		"GET /zones/zone-123/dns_records/rec-1": func(w http.ResponseWriter, r *http.Request) {
+			w.Header().Set("Content-Type", "application/json")
+			json.NewEncoder(w).Encode(cfSuccessEnvelope(
+				testCFRecordJSON("rec-1", "example.com", "A", "1.2.3.4", 300, nil, "test note"),
+			))
+		},
+	})
+
+	p := newTestCloudflareProvider(t, srv.URL)
+
+	rec, err := p.GetRecord(context.Background(), "example.com", "rec-1")
+	if err != nil {
+		t.Fatalf("expected no error, got %v", err)
+	}
+
+	want := &domain.Record{
+		ID:       "rec-1",
+		Domain:   "example.com",
+		Name:     "example.com",
+		Type:     domain.RecordTypeA,
+		Content:  "1.2.3.4",
+		TTL:      300,
+		Priority: 0,
+		Notes:    "test note",
+	}
+
+	if diff := cmp.Diff(want, rec); diff != "" {
+		t.Errorf("GetRecord mismatch (-want +got):\n%s", diff)
+	}
+}
+
+func TestCloudflare_GetRecord_NotFound(t *testing.T) {
+	srv := newCFRouter(t, map[string]http.HandlerFunc{
+		"GET /zones": func(w http.ResponseWriter, r *http.Request) {
+			w.Header().Set("Content-Type", "application/json")
+			json.NewEncoder(w).Encode(cfSuccessListEnvelope([]any{
+				testCFZoneJSON("zone-123", "example.com", "active"),
+			}, 1, 1, 1))
+		},
+		"GET /zones/zone-123/dns_records/rec-999": func(w http.ResponseWriter, r *http.Request) {
+			w.Header().Set("Content-Type", "application/json")
+			w.WriteHeader(http.StatusNotFound)
+			json.NewEncoder(w).Encode(cfErrorEnvelope(81044, "Record not found"))
+		},
+	})
+
+	p := newTestCloudflareProvider(t, srv.URL)
+
+	_, err := p.GetRecord(context.Background(), "example.com", "rec-999")
+	if err == nil {
+		t.Fatal("expected error, got nil")
+	}
+	if !errors.Is(err, domain.ErrNotFound) {
+		t.Errorf("expected ErrNotFound, got: %v", err)
+	}
+}
+
+// --- CreateRecord tests ---
+
+func TestCloudflare_CreateRecord_HappyPath(t *testing.T) {
+	var capturedBody cfCreateRecordBody
+	srv := newCFRouter(t, map[string]http.HandlerFunc{
+		"GET /zones": func(w http.ResponseWriter, r *http.Request) {
+			w.Header().Set("Content-Type", "application/json")
+			json.NewEncoder(w).Encode(cfSuccessListEnvelope([]any{
+				testCFZoneJSON("zone-123", "example.com", "active"),
+			}, 1, 1, 1))
+		},
+		"POST /zones/zone-123/dns_records": func(w http.ResponseWriter, r *http.Request) {
+			json.NewDecoder(r.Body).Decode(&capturedBody)
+			w.Header().Set("Content-Type", "application/json")
+			json.NewEncoder(w).Encode(cfSuccessEnvelope(
+				testCFRecordJSON("rec-new", "www.example.com", "A", "5.6.7.8", 300, nil, ""),
+			))
+		},
+	})
+
+	p := newTestCloudflareProvider(t, srv.URL)
+
+	rec, err := p.CreateRecord(context.Background(), "example.com", domain.CreateRecordOpts{
+		Name:    "www",
+		Type:    domain.RecordTypeA,
+		Content: "5.6.7.8",
+		TTL:     300,
+	})
+	if err != nil {
+		t.Fatalf("expected no error, got %v", err)
+	}
+
+	if rec.ID != "rec-new" {
+		t.Errorf("rec.ID = %q, want %q", rec.ID, "rec-new")
+	}
+	if rec.Content != "5.6.7.8" {
+		t.Errorf("rec.Content = %q, want %q", rec.Content, "5.6.7.8")
+	}
+
+	// Verify the request body had the FQDN.
+	if capturedBody.Name != "www.example.com" {
+		t.Errorf("request body name = %q, want %q", capturedBody.Name, "www.example.com")
+	}
+}
+
+func TestCloudflare_CreateRecord_RootDomain(t *testing.T) {
+	var capturedBody cfCreateRecordBody
+	srv := newCFRouter(t, map[string]http.HandlerFunc{
+		"GET /zones": func(w http.ResponseWriter, r *http.Request) {
+			w.Header().Set("Content-Type", "application/json")
+			json.NewEncoder(w).Encode(cfSuccessListEnvelope([]any{
+				testCFZoneJSON("zone-123", "example.com", "active"),
+			}, 1, 1, 1))
+		},
+		"POST /zones/zone-123/dns_records": func(w http.ResponseWriter, r *http.Request) {
+			json.NewDecoder(r.Body).Decode(&capturedBody)
+			w.Header().Set("Content-Type", "application/json")
+			json.NewEncoder(w).Encode(cfSuccessEnvelope(
+				testCFRecordJSON("rec-root", "example.com", "A", "1.2.3.4", 300, nil, ""),
+			))
+		},
+	})
+
+	p := newTestCloudflareProvider(t, srv.URL)
+
+	rec, err := p.CreateRecord(context.Background(), "example.com", domain.CreateRecordOpts{
+		Name:    "",
+		Type:    domain.RecordTypeA,
+		Content: "1.2.3.4",
+	})
+	if err != nil {
+		t.Fatalf("expected no error, got %v", err)
+	}
+
+	if rec.ID != "rec-root" {
+		t.Errorf("rec.ID = %q, want %q", rec.ID, "rec-root")
+	}
+
+	// Root domain should use just the domain name, not ".example.com".
+	if capturedBody.Name != "example.com" {
+		t.Errorf("request body name = %q, want %q", capturedBody.Name, "example.com")
+	}
+}
+
+func TestCloudflare_CreateRecord_Conflict(t *testing.T) {
+	srv := newCFRouter(t, map[string]http.HandlerFunc{
+		"GET /zones": func(w http.ResponseWriter, r *http.Request) {
+			w.Header().Set("Content-Type", "application/json")
+			json.NewEncoder(w).Encode(cfSuccessListEnvelope([]any{
+				testCFZoneJSON("zone-123", "example.com", "active"),
+			}, 1, 1, 1))
+		},
+		"POST /zones/zone-123/dns_records": func(w http.ResponseWriter, r *http.Request) {
+			w.Header().Set("Content-Type", "application/json")
+			w.WriteHeader(http.StatusConflict)
+			json.NewEncoder(w).Encode(cfErrorEnvelope(81057, "Record already exists"))
+		},
+	})
+
+	p := newTestCloudflareProvider(t, srv.URL)
+
+	_, err := p.CreateRecord(context.Background(), "example.com", domain.CreateRecordOpts{
+		Type:    domain.RecordTypeA,
+		Content: "1.1.1.1",
+	})
+	if err == nil {
+		t.Fatal("expected error, got nil")
+	}
+	if !errors.Is(err, domain.ErrConflict) {
+		t.Errorf("expected ErrConflict, got: %v", err)
+	}
+}
+
+// --- UpdateRecord tests ---
+
+func TestCloudflare_UpdateRecord_HappyPath(t *testing.T) {
+	var capturedMethod string
+	srv := newCFRouter(t, map[string]http.HandlerFunc{
+		"GET /zones": func(w http.ResponseWriter, r *http.Request) {
+			w.Header().Set("Content-Type", "application/json")
+			json.NewEncoder(w).Encode(cfSuccessListEnvelope([]any{
+				testCFZoneJSON("zone-123", "example.com", "active"),
+			}, 1, 1, 1))
+		},
+		"PATCH /zones/zone-123/dns_records/rec-1": func(w http.ResponseWriter, r *http.Request) {
+			capturedMethod = r.Method
+			w.Header().Set("Content-Type", "application/json")
+			json.NewEncoder(w).Encode(cfSuccessEnvelope(
+				testCFRecordJSON("rec-1", "example.com", "A", "9.9.9.9", 1800, nil, ""),
+			))
+		},
+	})
+
+	p := newTestCloudflareProvider(t, srv.URL)
+
+	err := p.UpdateRecord(context.Background(), "example.com", "rec-1", domain.UpdateRecordOpts{
+		Type:    domain.RecordTypeA,
+		Content: "9.9.9.9",
+		TTL:     1800,
+	})
+	if err != nil {
+		t.Fatalf("expected no error, got %v", err)
+	}
+	if capturedMethod != "PATCH" {
+		t.Errorf("expected PATCH method, got %s", capturedMethod)
+	}
+}
+
+func TestCloudflare_UpdateRecord_NotFound(t *testing.T) {
+	srv := newCFRouter(t, map[string]http.HandlerFunc{
+		"GET /zones": func(w http.ResponseWriter, r *http.Request) {
+			w.Header().Set("Content-Type", "application/json")
+			json.NewEncoder(w).Encode(cfSuccessListEnvelope([]any{
+				testCFZoneJSON("zone-123", "example.com", "active"),
+			}, 1, 1, 1))
+		},
+		"PATCH /zones/zone-123/dns_records/rec-999": func(w http.ResponseWriter, r *http.Request) {
+			w.Header().Set("Content-Type", "application/json")
+			w.WriteHeader(http.StatusNotFound)
+			json.NewEncoder(w).Encode(cfErrorEnvelope(81044, "Record not found"))
+		},
+	})
+
+	p := newTestCloudflareProvider(t, srv.URL)
+
+	err := p.UpdateRecord(context.Background(), "example.com", "rec-999", domain.UpdateRecordOpts{
+		Type:    domain.RecordTypeA,
+		Content: "1.1.1.1",
+	})
+	if err == nil {
+		t.Fatal("expected error, got nil")
+	}
+	if !errors.Is(err, domain.ErrNotFound) {
+		t.Errorf("expected ErrNotFound, got: %v", err)
+	}
+}
+
+// --- DeleteRecord tests ---
+
+func TestCloudflare_DeleteRecord_HappyPath(t *testing.T) {
+	var capturedPath string
+	srv := newCFRouter(t, map[string]http.HandlerFunc{
+		"GET /zones": func(w http.ResponseWriter, r *http.Request) {
+			w.Header().Set("Content-Type", "application/json")
+			json.NewEncoder(w).Encode(cfSuccessListEnvelope([]any{
+				testCFZoneJSON("zone-123", "example.com", "active"),
+			}, 1, 1, 1))
+		},
+		"DELETE /zones/zone-123/dns_records/rec-1": func(w http.ResponseWriter, r *http.Request) {
+			capturedPath = r.URL.Path
+			w.Header().Set("Content-Type", "application/json")
+			json.NewEncoder(w).Encode(cfSuccessEnvelope(
+				map[string]any{"id": "rec-1"},
+			))
+		},
+	})
+
+	p := newTestCloudflareProvider(t, srv.URL)
+
+	err := p.DeleteRecord(context.Background(), "example.com", "rec-1")
+	if err != nil {
+		t.Fatalf("expected no error, got %v", err)
+	}
+	if capturedPath != "/zones/zone-123/dns_records/rec-1" {
+		t.Errorf("expected path /zones/zone-123/dns_records/rec-1, got %s", capturedPath)
+	}
+}
+
+func TestCloudflare_DeleteRecord_NotFound(t *testing.T) {
+	srv := newCFRouter(t, map[string]http.HandlerFunc{
+		"GET /zones": func(w http.ResponseWriter, r *http.Request) {
+			w.Header().Set("Content-Type", "application/json")
+			json.NewEncoder(w).Encode(cfSuccessListEnvelope([]any{
+				testCFZoneJSON("zone-123", "example.com", "active"),
+			}, 1, 1, 1))
+		},
+		"DELETE /zones/zone-123/dns_records/rec-999": func(w http.ResponseWriter, r *http.Request) {
+			w.Header().Set("Content-Type", "application/json")
+			w.WriteHeader(http.StatusNotFound)
+			json.NewEncoder(w).Encode(cfErrorEnvelope(81044, "Record not found"))
+		},
+	})
+
+	p := newTestCloudflareProvider(t, srv.URL)
+
+	err := p.DeleteRecord(context.Background(), "example.com", "rec-999")
+	if err == nil {
+		t.Fatal("expected error, got nil")
+	}
+	if !errors.Is(err, domain.ErrNotFound) {
+		t.Errorf("expected ErrNotFound, got: %v", err)
+	}
+}
+
+// --- Auth header tests ---
+
+func TestCloudflare_BearerTokenSent(t *testing.T) {
+	var capturedAuth string
+	srv := newCFRouter(t, map[string]http.HandlerFunc{
+		"GET /zones": func(w http.ResponseWriter, r *http.Request) {
+			capturedAuth = r.Header.Get("Authorization")
+			w.Header().Set("Content-Type", "application/json")
+			json.NewEncoder(w).Encode(cfSuccessListEnvelope([]any{}, 1, 1, 0))
+		},
+	})
+
+	p := newTestCloudflareProvider(t, srv.URL)
+
+	p.ListDomains(context.Background())
+
+	if capturedAuth != "Bearer test-token" {
+		t.Errorf("expected Authorization = %q, got %q", "Bearer test-token", capturedAuth)
+	}
+}
+
+// --- Registry tests ---
+
+func TestCloudflare_Registry_RegisterAndGet(t *testing.T) {
+	Reset()
+	t.Cleanup(Reset)
+
+	store := auth.NewMockStore()
+	store.SetToken(cloudflareTokenStore, "cf-test-token")
+
+	RegisterCloudflare()
+
+	p, err := Get("cloudflare", store)
+	if err != nil {
+		t.Fatalf("expected no error, got %v", err)
+	}
+	if p.GetDisplayName() != "Cloudflare" {
+		t.Errorf("GetDisplayName = %q, want %q", p.GetDisplayName(), "Cloudflare")
+	}
+}
+
+func TestCloudflare_Registry_MissingToken(t *testing.T) {
+	Reset()
+	t.Cleanup(Reset)
+
+	store := auth.NewMockStore()
+	// No token set.
+
+	RegisterCloudflare()
+
+	_, err := Get("cloudflare", store)
+	if err == nil {
+		t.Fatal("expected error for missing token, got nil")
+	}
+}
diff --git a/internal/dns/providers/http_timing_test.go b/internal/dns/providers/http_timing_test.go
new file mode 100644
index 0000000..757a153
--- /dev/null
+++ b/internal/dns/providers/http_timing_test.go
@@ -0,0 +1,26 @@
+//go:build integration
+
+package providers
+
+import (
+	"bytes"
+	"encoding/json"
+	"net/http"
+	"testing"
+	"time"
+)
+
+func TestHTTPTimingPorkbun(t *testing.T) {
+	client := &http.Client{Timeout: 30 * time.Second}
+	body, _ := json.Marshal(map[string]string{"apikey": "invalid", "secretapikey": "invalid"})
+
+	for i := range 3 {
+		start := time.Now()
+		resp, err := client.Post("https://api.porkbun.com/api/json/v3/domain/listAll", "application/json", bytes.NewReader(body))
+		elapsed := time.Since(start)
+		t.Logf("Call %d: %v (err=%v)", i+1, elapsed, err)
+		if resp != nil {
+			resp.Body.Close()
+		}
+	}
+}
diff --git a/internal/dns/providers/porkbun.go b/internal/dns/providers/porkbun.go
new file mode 100644
index 0000000..a74f8b6
--- /dev/null
+++ b/internal/dns/providers/porkbun.go
@@ -0,0 +1,366 @@
+package providers
+
+import (
+	"bytes"
+	"context"
+	"encoding/json"
+	"fmt"
+	"net/http"
+	"strings"
+	"time"
+
+	"nathanbeddoewebdev/vpsm/internal/dns/domain"
+	"nathanbeddoewebdev/vpsm/internal/services/auth"
+)
+
+const (
+	porkbunBaseURL     = "https://api.porkbun.com/api/json/v3"
+	porkbunTimeout     = 30 * time.Second
+	porkbunAPIKeyStore = "porkbun-apikey"
+	porkbunSecretStore = "porkbun-secretapikey"
+)
+
+// Compile-time check that PorkbunProvider satisfies domain.Provider.
+var _ domain.Provider = (*PorkbunProvider)(nil)
+
+// PorkbunProvider implements domain.Provider using the Porkbun API v3.
+type PorkbunProvider struct {
+	apiKey    string
+	secretKey string
+	baseURL   string
+	client    *http.Client
+}
+
+// NewPorkbunProvider creates a PorkbunProvider with the given credentials.
+func NewPorkbunProvider(apiKey, secretKey string) *PorkbunProvider {
+	return &PorkbunProvider{
+		apiKey:    apiKey,
+		secretKey: secretKey,
+		baseURL:   porkbunBaseURL,
+		client:    &http.Client{Timeout: porkbunTimeout},
+	}
+}
+
+// RegisterPorkbun registers the Porkbun provider factory with the DNS registry.
+// It reads two separate keychain entries: porkbun-apikey and porkbun-secretapikey.
+func RegisterPorkbun() {
+	Register("porkbun", func(store auth.Store) (domain.Provider, error) {
+		apiKey, err := store.GetToken(porkbunAPIKeyStore)
+		if err != nil {
+			return nil, fmt.Errorf("porkbun auth: api key not found (run 'vpsm auth login porkbun'): %w", err)
+		}
+		secretKey, err := store.GetToken(porkbunSecretStore)
+		if err != nil {
+			return nil, fmt.Errorf("porkbun auth: secret key not found (run 'vpsm auth login porkbun'): %w", err)
+		}
+		return NewPorkbunProvider(apiKey, secretKey), nil
+	})
+}
+
+// GetDisplayName returns the human-readable provider name.
+func (p *PorkbunProvider) GetDisplayName() string {
+	return "Porkbun"
+}
+
+// --- API request/response types ---
+
+// porkbunAuth is embedded in every request body.
+type porkbunAuth struct {
+	APIKey    string `json:"apikey"`
+	SecretKey string `json:"secretapikey"`
+}
+
+// porkbunResponse is the base response shape for all Porkbun API calls.
+type porkbunResponse struct {
+	Status  string `json:"status"`
+	Message string `json:"message,omitempty"`
+}
+
+func (r porkbunResponse) err() error {
+	if r.Status != "SUCCESS" {
+		return fmt.Errorf("porkbun: %s", r.Message)
+	}
+	return nil
+}
+
+// porkbunDomainRecord maps to the Porkbun DNS record object.
+type porkbunDomainRecord struct {
+	ID      string `json:"id"`
+	Name    string `json:"name"`
+	Type    string `json:"type"`
+	Content string `json:"content"`
+	TTL     string `json:"ttl"`
+	Prio    string `json:"prio"`
+	Notes   string `json:"notes"`
+}
+
+// --- HTTP helpers ---
+
+// post sends a POST request to the given path with the JSON body,
+// and decodes the response into out.
+func (p *PorkbunProvider) post(ctx context.Context, path string, body any, out any) error {
+	data, err := json.Marshal(body)
+	if err != nil {
+		return fmt.Errorf("porkbun: failed to encode request: %w", err)
+	}
+
+	req, err := http.NewRequestWithContext(ctx, http.MethodPost, p.baseURL+path, bytes.NewReader(data))
+	if err != nil {
+		return fmt.Errorf("porkbun: failed to build request: %w", err)
+	}
+	req.Header.Set("Content-Type", "application/json")
+
+	resp, err := p.client.Do(req)
+	if err != nil {
+		return fmt.Errorf("porkbun: request failed: %w", err)
+	}
+	defer resp.Body.Close()
+
+	if err := json.NewDecoder(resp.Body).Decode(out); err != nil {
+		return fmt.Errorf("porkbun: failed to decode response: %w", err)
+	}
+
+	return nil
+}
+
+// authBody returns the base request body with credentials embedded.
+func (p *PorkbunProvider) authBody() porkbunAuth {
+	return porkbunAuth{APIKey: p.apiKey, SecretKey: p.secretKey}
+}
+
+// mapAPIError converts Porkbun error messages to domain sentinels where recognisable.
+func mapAPIError(err error) error {
+	if err == nil {
+		return nil
+	}
+	msg := strings.ToLower(err.Error())
+	switch {
+	case strings.Contains(msg, "invalid api key") ||
+		strings.Contains(msg, "unauthorized") ||
+		strings.Contains(msg, "authentication"):
+		return fmt.Errorf("%w: %s", domain.ErrUnauthorized, err.Error())
+	case strings.Contains(msg, "not found") ||
+		strings.Contains(msg, "does not exist") ||
+		strings.Contains(msg, "invalid domain"):
+		return fmt.Errorf("%w: %s", domain.ErrNotFound, err.Error())
+	case strings.Contains(msg, "rate limit") ||
+		strings.Contains(msg, "too many requests"):
+		return fmt.Errorf("%w: %s", domain.ErrRateLimited, err.Error())
+	case strings.Contains(msg, "already exists") ||
+		strings.Contains(msg, "duplicate") ||
+		strings.Contains(msg, "conflict"):
+		return fmt.Errorf("%w: %s", domain.ErrConflict, err.Error())
+	}
+	return err
+}
+
+// --- Provider implementation ---
+
+// ListDomains returns all domains in the Porkbun account.
+func (p *PorkbunProvider) ListDomains(ctx context.Context) ([]domain.Domain, error) {
+	type request struct {
+		porkbunAuth
+		Start         string `json:"start,omitempty"`
+		IncludeLabels string `json:"includeLabels,omitempty"`
+	}
+
+	type apiDomain struct {
+		Domain     string `json:"domain"`
+		Status     string `json:"status"`
+		TLD        string `json:"tld"`
+		CreateDate string `json:"createDate"`
+		ExpireDate string `json:"expireDate"`
+	}
+
+	type response struct {
+		porkbunResponse
+		Domains []apiDomain `json:"domains"`
+	}
+
+	var out response
+	if err := p.post(ctx, "/domain/listAll", request{porkbunAuth: p.authBody()}, &out); err != nil {
+		return nil, fmt.Errorf("failed to list domains: %w", err)
+	}
+	if err := mapAPIError(out.err()); err != nil {
+		return nil, fmt.Errorf("failed to list domains: %w", err)
+	}
+
+	domains := make([]domain.Domain, 0, len(out.Domains))
+	for _, d := range out.Domains {
+		domains = append(domains, domain.Domain{
+			Name:       d.Domain,
+			Status:     d.Status,
+			TLD:        d.TLD,
+			CreateDate: d.CreateDate,
+			ExpireDate: d.ExpireDate,
+		})
+	}
+	return domains, nil
+}
+
+// ListRecords returns all DNS records for the given domain.
+func (p *PorkbunProvider) ListRecords(ctx context.Context, domainName string) ([]domain.Record, error) {
+	type response struct {
+		porkbunResponse
+		Records []porkbunDomainRecord `json:"records"`
+	}
+
+	var out response
+	if err := p.post(ctx, "/dns/retrieve/"+domainName, p.authBody(), &out); err != nil {
+		return nil, fmt.Errorf("failed to list records for %q: %w", domainName, err)
+	}
+	if err := mapAPIError(out.err()); err != nil {
+		return nil, fmt.Errorf("failed to list records for %q: %w", domainName, err)
+	}
+
+	records := make([]domain.Record, 0, len(out.Records))
+	for _, r := range out.Records {
+		records = append(records, toDomainRecord(domainName, r))
+	}
+	return records, nil
+}
+
+// GetRecord returns a single DNS record by its ID.
+func (p *PorkbunProvider) GetRecord(ctx context.Context, domainName string, id string) (*domain.Record, error) {
+	type response struct {
+		porkbunResponse
+		Records []porkbunDomainRecord `json:"records"`
+	}
+
+	var out response
+	if err := p.post(ctx, "/dns/retrieve/"+domainName+"/"+id, p.authBody(), &out); err != nil {
+		return nil, fmt.Errorf("failed to get record %q for %q: %w", id, domainName, err)
+	}
+	if err := mapAPIError(out.err()); err != nil {
+		return nil, fmt.Errorf("failed to get record %q for %q: %w", id, domainName, err)
+	}
+
+	if len(out.Records) == 0 {
+		return nil, fmt.Errorf("record %q for %q: %w", id, domainName, domain.ErrNotFound)
+	}
+
+	rec := toDomainRecord(domainName, out.Records[0])
+	return &rec, nil
+}
+
+// CreateRecord creates a new DNS record and returns the created record with its assigned ID.
+func (p *PorkbunProvider) CreateRecord(ctx context.Context, domainName string, opts domain.CreateRecordOpts) (*domain.Record, error) {
+	type request struct {
+		porkbunAuth
+		Name    string `json:"name,omitempty"`
+		Type    string `json:"type"`
+		Content string `json:"content"`
+		TTL     string `json:"ttl,omitempty"`
+		Prio    string `json:"prio,omitempty"`
+		Notes   string `json:"notes,omitempty"`
+	}
+
+	type response struct {
+		porkbunResponse
+		ID string `json:"id"`
+	}
+
+	body := request{
+		porkbunAuth: p.authBody(),
+		Name:        opts.Name,
+		Type:        string(opts.Type),
+		Content:     opts.Content,
+		Notes:       opts.Notes,
+	}
+	if opts.TTL > 0 {
+		body.TTL = fmt.Sprintf("%d", opts.TTL)
+	}
+	if opts.Priority > 0 {
+		body.Prio = fmt.Sprintf("%d", opts.Priority)
+	}
+
+	var out response
+	if err := p.post(ctx, "/dns/create/"+domainName, body, &out); err != nil {
+		return nil, fmt.Errorf("failed to create record for %q: %w", domainName, err)
+	}
+	if err := mapAPIError(out.err()); err != nil {
+		return nil, fmt.Errorf("failed to create record for %q: %w", domainName, err)
+	}
+
+	// Fetch the newly created record so we can return a fully-populated struct.
+	return p.GetRecord(ctx, domainName, out.ID)
+}
+
+// UpdateRecord updates an existing DNS record by its ID.
+func (p *PorkbunProvider) UpdateRecord(ctx context.Context, domainName string, id string, opts domain.UpdateRecordOpts) error {
+	type request struct {
+		porkbunAuth
+		Name    string  `json:"name,omitempty"`
+		Type    string  `json:"type"`
+		Content string  `json:"content"`
+		TTL     string  `json:"ttl,omitempty"`
+		Prio    string  `json:"prio,omitempty"`
+		Notes   *string `json:"notes"`
+	}
+
+	body := request{
+		porkbunAuth: p.authBody(),
+		Name:        opts.Name,
+		Type:        string(opts.Type),
+		Content:     opts.Content,
+		Notes:       opts.Notes,
+	}
+	if opts.TTL > 0 {
+		body.TTL = fmt.Sprintf("%d", opts.TTL)
+	}
+	if opts.Priority > 0 {
+		body.Prio = fmt.Sprintf("%d", opts.Priority)
+	}
+
+	var out porkbunResponse
+	if err := p.post(ctx, "/dns/edit/"+domainName+"/"+id, body, &out); err != nil {
+		return fmt.Errorf("failed to update record %q for %q: %w", id, domainName, err)
+	}
+	if err := mapAPIError(out.err()); err != nil {
+		return fmt.Errorf("failed to update record %q for %q: %w", id, domainName, err)
+	}
+
+	return nil
+}
+
+// DeleteRecord deletes a DNS record by its ID.
+func (p *PorkbunProvider) DeleteRecord(ctx context.Context, domainName string, id string) error {
+	var out porkbunResponse
+	if err := p.post(ctx, "/dns/delete/"+domainName+"/"+id, p.authBody(), &out); err != nil {
+		return fmt.Errorf("failed to delete record %q for %q: %w", id, domainName, err)
+	}
+	if err := mapAPIError(out.err()); err != nil {
+		return fmt.Errorf("failed to delete record %q for %q: %w", id, domainName, err)
+	}
+
+	return nil
+}
+
+// --- Conversion helpers ---
+
+// toDomainRecord converts a Porkbun API record to a domain.Record.
+func toDomainRecord(domainName string, r porkbunDomainRecord) domain.Record {
+	ttl := parseInt(r.TTL)
+	prio := parseInt(r.Prio)
+
+	return domain.Record{
+		ID:       r.ID,
+		Domain:   domainName,
+		Name:     r.Name,
+		Type:     domain.RecordType(r.Type),
+		Content:  r.Content,
+		TTL:      ttl,
+		Priority: prio,
+		Notes:    r.Notes,
+	}
+}
+
+// parseInt converts a string to int, returning 0 on failure.
+func parseInt(s string) int {
+	if s == "" {
+		return 0
+	}
+	var n int
+	fmt.Sscanf(s, "%d", &n)
+	return n
+}
diff --git a/internal/dns/providers/porkbun_test.go b/internal/dns/providers/porkbun_test.go
new file mode 100644
index 0000000..7d4e506
--- /dev/null
+++ b/internal/dns/providers/porkbun_test.go
@@ -0,0 +1,429 @@
+package providers
+
+import (
+	"context"
+	"encoding/json"
+	"errors"
+	"maps"
+	"net/http"
+	"net/http/httptest"
+	"testing"
+
+	"nathanbeddoewebdev/vpsm/internal/dns/domain"
+	"nathanbeddoewebdev/vpsm/internal/services/auth"
+
+	"github.com/google/go-cmp/cmp"
+)
+
+// --- Test helpers ---
+
+// newTestPorkbunProvider creates a PorkbunProvider pointed at the given test server.
+func newTestPorkbunProvider(t *testing.T, serverURL string) *PorkbunProvider {
+	t.Helper()
+	p := NewPorkbunProvider("test-api-key", "test-secret-key")
+	p.baseURL = serverURL
+	return p
+}
+
+// porkbunSuccess returns a minimal success response body.
+func porkbunSuccess(extra map[string]any) map[string]any {
+	m := map[string]any{"status": "SUCCESS"}
+	maps.Copy(m, extra)
+	return m
+}
+
+// porkbunError returns an error response body.
+func porkbunError(message string) map[string]any {
+	return map[string]any{
+		"status":  "ERROR",
+		"message": message,
+	}
+}
+
+// newStaticServer creates an httptest.Server that always returns the given JSON.
+func newStaticServer(t *testing.T, body any) *httptest.Server {
+	t.Helper()
+	srv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+		w.Header().Set("Content-Type", "application/json")
+		if err := json.NewEncoder(w).Encode(body); err != nil {
+			t.Fatalf("failed to encode test response: %v", err)
+		}
+	}))
+	t.Cleanup(srv.Close)
+	return srv
+}
+
+// testRecordJSON returns a sample Porkbun API record object.
+func testRecordJSON(id, name, typ, content, ttl, prio string) map[string]any {
+	return map[string]any{
+		"id":      id,
+		"name":    name,
+		"type":    typ,
+		"content": content,
+		"ttl":     ttl,
+		"prio":    prio,
+		"notes":   "",
+	}
+}
+
+// --- ListDomains tests ---
+
+func TestListDomains_HappyPath(t *testing.T) {
+	body := porkbunSuccess(map[string]any{
+		"domains": []any{
+			map[string]any{
+				"domain":     "example.com",
+				"status":     "ACTIVE",
+				"tld":        "com",
+				"createDate": "2022-01-01 00:00:00",
+				"expireDate": "2025-01-01 00:00:00",
+			},
+			map[string]any{
+				"domain":     "another.io",
+				"status":     "ACTIVE",
+				"tld":        "io",
+				"createDate": "2023-06-15 00:00:00",
+				"expireDate": "2024-06-15 00:00:00",
+			},
+		},
+	})
+
+	srv := newStaticServer(t, body)
+	p := newTestPorkbunProvider(t, srv.URL)
+
+	domains, err := p.ListDomains(context.Background())
+	if err != nil {
+		t.Fatalf("expected no error, got %v", err)
+	}
+	if len(domains) != 2 {
+		t.Fatalf("expected 2 domains, got %d", len(domains))
+	}
+
+	want := []domain.Domain{
+		{Name: "example.com", Status: "ACTIVE", TLD: "com", CreateDate: "2022-01-01 00:00:00", ExpireDate: "2025-01-01 00:00:00"},
+		{Name: "another.io", Status: "ACTIVE", TLD: "io", CreateDate: "2023-06-15 00:00:00", ExpireDate: "2024-06-15 00:00:00"},
+	}
+
+	if diff := cmp.Diff(want, domains); diff != "" {
+		t.Errorf("ListDomains mismatch (-want +got):\n%s", diff)
+	}
+}
+
+func TestListDomains_EmptyList(t *testing.T) {
+	srv := newStaticServer(t, porkbunSuccess(map[string]any{
+		"domains": []any{},
+	}))
+	p := newTestPorkbunProvider(t, srv.URL)
+
+	domains, err := p.ListDomains(context.Background())
+	if err != nil {
+		t.Fatalf("expected no error, got %v", err)
+	}
+	if len(domains) != 0 {
+		t.Errorf("expected 0 domains, got %d", len(domains))
+	}
+}
+
+func TestListDomains_Unauthorized(t *testing.T) {
+	srv := newStaticServer(t, porkbunError("Invalid API key or secret."))
+	p := newTestPorkbunProvider(t, srv.URL)
+
+	_, err := p.ListDomains(context.Background())
+	if err == nil {
+		t.Fatal("expected error, got nil")
+	}
+	if !errors.Is(err, domain.ErrUnauthorized) {
+		t.Errorf("expected ErrUnauthorized, got: %v", err)
+	}
+}
+
+// --- ListRecords tests ---
+
+func TestListRecords_HappyPath(t *testing.T) {
+	body := porkbunSuccess(map[string]any{
+		"records": []any{
+			testRecordJSON("101", "example.com", "A", "1.2.3.4", "600", "0"),
+			testRecordJSON("102", "www.example.com", "A", "1.2.3.4", "600", "0"),
+			testRecordJSON("103", "example.com", "MX", "mail.example.com", "3600", "10"),
+		},
+	})
+
+	srv := newStaticServer(t, body)
+	p := newTestPorkbunProvider(t, srv.URL)
+
+	records, err := p.ListRecords(context.Background(), "example.com")
+	if err != nil {
+		t.Fatalf("expected no error, got %v", err)
+	}
+	if len(records) != 3 {
+		t.Fatalf("expected 3 records, got %d", len(records))
+	}
+
+	if records[0].ID != "101" {
+		t.Errorf("records[0].ID = %q, want %q", records[0].ID, "101")
+	}
+	if records[2].Priority != 10 {
+		t.Errorf("records[2].Priority = %d, want 10", records[2].Priority)
+	}
+}
+
+func TestListRecords_NotFound(t *testing.T) {
+	srv := newStaticServer(t, porkbunError("Domain does not exist."))
+	p := newTestPorkbunProvider(t, srv.URL)
+
+	_, err := p.ListRecords(context.Background(), "notexist.com")
+	if err == nil {
+		t.Fatal("expected error, got nil")
+	}
+	if !errors.Is(err, domain.ErrNotFound) {
+		t.Errorf("expected ErrNotFound, got: %v", err)
+	}
+}
+
+// --- GetRecord tests ---
+
+func TestGetRecord_HappyPath(t *testing.T) {
+	body := porkbunSuccess(map[string]any{
+		"records": []any{
+			testRecordJSON("101", "example.com", "A", "1.2.3.4", "600", "0"),
+		},
+	})
+
+	srv := newStaticServer(t, body)
+	p := newTestPorkbunProvider(t, srv.URL)
+
+	rec, err := p.GetRecord(context.Background(), "example.com", "101")
+	if err != nil {
+		t.Fatalf("expected no error, got %v", err)
+	}
+
+	want := &domain.Record{
+		ID:       "101",
+		Domain:   "example.com",
+		Name:     "example.com",
+		Type:     domain.RecordTypeA,
+		Content:  "1.2.3.4",
+		TTL:      600,
+		Priority: 0,
+		Notes:    "",
+	}
+
+	if diff := cmp.Diff(want, rec); diff != "" {
+		t.Errorf("GetRecord mismatch (-want +got):\n%s", diff)
+	}
+}
+
+func TestGetRecord_EmptyRecords(t *testing.T) {
+	srv := newStaticServer(t, porkbunSuccess(map[string]any{
+		"records": []any{},
+	}))
+	p := newTestPorkbunProvider(t, srv.URL)
+
+	_, err := p.GetRecord(context.Background(), "example.com", "999")
+	if err == nil {
+		t.Fatal("expected error for empty records, got nil")
+	}
+	if !errors.Is(err, domain.ErrNotFound) {
+		t.Errorf("expected ErrNotFound, got: %v", err)
+	}
+}
+
+// --- CreateRecord tests ---
+
+func TestCreateRecord_HappyPath(t *testing.T) {
+	// First call returns the create response, second returns the record.
+	callCount := 0
+	srv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+		callCount++
+		w.Header().Set("Content-Type", "application/json")
+		var body any
+		if callCount == 1 {
+			// POST /dns/create/example.com
+			body = porkbunSuccess(map[string]any{"id": "201"})
+		} else {
+			// POST /dns/retrieve/example.com/201
+			body = porkbunSuccess(map[string]any{
+				"records": []any{
+					testRecordJSON("201", "www.example.com", "A", "5.6.7.8", "600", "0"),
+				},
+			})
+		}
+		json.NewEncoder(w).Encode(body)
+	}))
+	t.Cleanup(srv.Close)
+
+	p := newTestPorkbunProvider(t, srv.URL)
+
+	rec, err := p.CreateRecord(context.Background(), "example.com", domain.CreateRecordOpts{
+		Name:    "www",
+		Type:    domain.RecordTypeA,
+		Content: "5.6.7.8",
+		TTL:     600,
+	})
+	if err != nil {
+		t.Fatalf("expected no error, got %v", err)
+	}
+
+	if rec.ID != "201" {
+		t.Errorf("rec.ID = %q, want %q", rec.ID, "201")
+	}
+	if rec.Content != "5.6.7.8" {
+		t.Errorf("rec.Content = %q, want %q", rec.Content, "5.6.7.8")
+	}
+	if callCount != 2 {
+		t.Errorf("expected 2 API calls (create + fetch), got %d", callCount)
+	}
+}
+
+func TestCreateRecord_APIError(t *testing.T) {
+	srv := newStaticServer(t, porkbunError("Record already exists."))
+	p := newTestPorkbunProvider(t, srv.URL)
+
+	_, err := p.CreateRecord(context.Background(), "example.com", domain.CreateRecordOpts{
+		Type:    domain.RecordTypeA,
+		Content: "1.1.1.1",
+	})
+	if err == nil {
+		t.Fatal("expected error, got nil")
+	}
+}
+
+// --- UpdateRecord tests ---
+
+func TestUpdateRecord_HappyPath(t *testing.T) {
+	var capturedPath string
+	srv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+		capturedPath = r.URL.Path
+		w.Header().Set("Content-Type", "application/json")
+		json.NewEncoder(w).Encode(porkbunSuccess(nil))
+	}))
+	t.Cleanup(srv.Close)
+
+	p := newTestPorkbunProvider(t, srv.URL)
+
+	err := p.UpdateRecord(context.Background(), "example.com", "101", domain.UpdateRecordOpts{
+		Type:    domain.RecordTypeA,
+		Content: "9.9.9.9",
+		TTL:     1800,
+	})
+	if err != nil {
+		t.Fatalf("expected no error, got %v", err)
+	}
+	if capturedPath != "/dns/edit/example.com/101" {
+		t.Errorf("expected path /dns/edit/example.com/101, got %s", capturedPath)
+	}
+}
+
+func TestUpdateRecord_NotFound(t *testing.T) {
+	srv := newStaticServer(t, porkbunError("Record does not exist."))
+	p := newTestPorkbunProvider(t, srv.URL)
+
+	err := p.UpdateRecord(context.Background(), "example.com", "999", domain.UpdateRecordOpts{
+		Type:    domain.RecordTypeA,
+		Content: "1.1.1.1",
+	})
+	if err == nil {
+		t.Fatal("expected error, got nil")
+	}
+	if !errors.Is(err, domain.ErrNotFound) {
+		t.Errorf("expected ErrNotFound, got: %v", err)
+	}
+}
+
+// --- DeleteRecord tests ---
+
+func TestDeleteRecord_HappyPath(t *testing.T) {
+	var capturedPath string
+	srv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+		capturedPath = r.URL.Path
+		w.Header().Set("Content-Type", "application/json")
+		json.NewEncoder(w).Encode(porkbunSuccess(nil))
+	}))
+	t.Cleanup(srv.Close)
+
+	p := newTestPorkbunProvider(t, srv.URL)
+
+	err := p.DeleteRecord(context.Background(), "example.com", "101")
+	if err != nil {
+		t.Fatalf("expected no error, got %v", err)
+	}
+	if capturedPath != "/dns/delete/example.com/101" {
+		t.Errorf("expected path /dns/delete/example.com/101, got %s", capturedPath)
+	}
+}
+
+func TestDeleteRecord_NotFound(t *testing.T) {
+	srv := newStaticServer(t, porkbunError("Record does not exist."))
+	p := newTestPorkbunProvider(t, srv.URL)
+
+	err := p.DeleteRecord(context.Background(), "example.com", "999")
+	if err == nil {
+		t.Fatal("expected error, got nil")
+	}
+	if !errors.Is(err, domain.ErrNotFound) {
+		t.Errorf("expected ErrNotFound, got: %v", err)
+	}
+}
+
+// --- Registry tests ---
+
+func TestRegistry_RegisterAndGet(t *testing.T) {
+	Reset()
+	t.Cleanup(Reset)
+
+	store := auth.NewMockStore()
+	store.SetToken(porkbunAPIKeyStore, "ak")
+	store.SetToken(porkbunSecretStore, "sk")
+
+	RegisterPorkbun()
+
+	p, err := Get("porkbun", store)
+	if err != nil {
+		t.Fatalf("expected no error, got %v", err)
+	}
+	if p.GetDisplayName() != "Porkbun" {
+		t.Errorf("GetDisplayName = %q, want %q", p.GetDisplayName(), "Porkbun")
+	}
+}
+
+func TestRegistry_MissingAPIKey(t *testing.T) {
+	Reset()
+	t.Cleanup(Reset)
+
+	store := auth.NewMockStore()
+	// Only set secret, not api key
+	store.SetToken(porkbunSecretStore, "sk")
+
+	RegisterPorkbun()
+
+	_, err := Get("porkbun", store)
+	if err == nil {
+		t.Fatal("expected error for missing api key, got nil")
+	}
+}
+
+func TestRegistry_MissingSecretKey(t *testing.T) {
+	Reset()
+	t.Cleanup(Reset)
+
+	store := auth.NewMockStore()
+	// Only set api key, not secret
+	store.SetToken(porkbunAPIKeyStore, "ak")
+
+	RegisterPorkbun()
+
+	_, err := Get("porkbun", store)
+	if err == nil {
+		t.Fatal("expected error for missing secret key, got nil")
+	}
+}
+
+func TestRegistry_UnknownProvider(t *testing.T) {
+	Reset()
+	t.Cleanup(Reset)
+
+	_, err := Get("nonexistent", auth.NewMockStore())
+	if err == nil {
+		t.Fatal("expected error for unknown provider, got nil")
+	}
+}
diff --git a/internal/dns/providers/registry.go b/internal/dns/providers/registry.go
new file mode 100644
index 0000000..9dbe928
--- /dev/null
+++ b/internal/dns/providers/registry.go
@@ -0,0 +1,73 @@
+package providers
+
+import (
+	"fmt"
+	"sync"
+
+	"nathanbeddoewebdev/vpsm/internal/dns/domain"
+	"nathanbeddoewebdev/vpsm/internal/services/auth"
+	"nathanbeddoewebdev/vpsm/internal/util"
+)
+
+// Factory is a constructor function that builds a DNS Provider given an auth store.
+type Factory func(store auth.Store) (domain.Provider, error)
+
+var (
+	mu       sync.RWMutex
+	registry = map[string]Factory{}
+)
+
+// Register adds a provider factory to the DNS registry.
+// It panics on empty name, nil factory, or duplicate registration
+// (programmer errors detected at startup).
+func Register(name string, factory Factory) {
+	normalizedName := util.NormalizeKey(name)
+	if normalizedName == "" {
+		panic("dns/providers: empty provider name")
+	}
+	if factory == nil {
+		panic("dns/providers: nil factory")
+	}
+
+	mu.Lock()
+	defer mu.Unlock()
+	if _, exists := registry[normalizedName]; exists {
+		panic(fmt.Sprintf("dns/providers: provider %q already registered", name))
+	}
+
+	registry[normalizedName] = factory
+}
+
+// Get constructs and returns the DNS Provider for the given name,
+// using the store to retrieve credentials.
+func Get(name string, store auth.Store) (domain.Provider, error) {
+	normalizedName := util.NormalizeKey(name)
+	mu.RLock()
+	factory, ok := registry[normalizedName]
+	mu.RUnlock()
+
+	if !ok {
+		return nil, fmt.Errorf("dns/providers: unknown provider %q", name)
+	}
+
+	return factory(store)
+}
+
+// List returns the names of all registered DNS providers.
+func List() []string {
+	mu.RLock()
+	defer mu.RUnlock()
+
+	names := make([]string, 0, len(registry))
+	for name := range registry {
+		names = append(names, name)
+	}
+	return names
+}
+
+// Reset clears the DNS provider registry. Intended for use in tests only.
+func Reset() {
+	mu.Lock()
+	defer mu.Unlock()
+	registry = map[string]Factory{}
+}
diff --git a/internal/dns/services/cache.go b/internal/dns/services/cache.go
new file mode 100644
index 0000000..32acce2
--- /dev/null
+++ b/internal/dns/services/cache.go
@@ -0,0 +1,25 @@
+package services
+
+import (
+	"strings"
+
+	"nathanbeddoewebdev/vpsm/internal/util"
+)
+
+func cacheKey(provider string, parts ...string) string {
+	values := make([]string, 0, len(parts)+1)
+	if provider != "" {
+		values = append(values, util.NormalizeKey(provider))
+	}
+	for _, part := range parts {
+		part = strings.TrimSpace(part)
+		if part == "" {
+			continue
+		}
+		values = append(values, util.NormalizeKey(part))
+	}
+	if len(values) == 0 {
+		return "dns"
+	}
+	return strings.Join(values, "_")
+}
diff --git a/internal/dns/services/service.go b/internal/dns/services/service.go
new file mode 100644
index 0000000..6c8f70d
--- /dev/null
+++ b/internal/dns/services/service.go
@@ -0,0 +1,160 @@
+// Package services provides the DNS service layer.
+//
+// The Service type wraps a domain.Provider and adds input normalisation,
+// validation, and default value application before delegating to the provider.
+// CLI commands construct a Service from a resolved provider and call service
+// methods rather than calling the provider directly.
+package services
+
+import (
+	"context"
+	"fmt"
+
+	"nathanbeddoewebdev/vpsm/internal/dns/domain"
+	"nathanbeddoewebdev/vpsm/internal/swrcache"
+)
+
+// Service is the DNS business logic layer. It sits between CLI commands and
+// the provider, applying normalisation and validation to all inputs.
+type Service struct {
+	provider domain.Provider
+	cache    *swrcache.Cache
+}
+
+// Option configures a Service.
+type Option func(*Service)
+
+// WithCache enables stale-while-revalidate caching for read operations.
+func WithCache(cache *swrcache.Cache) Option {
+	return func(s *Service) {
+		s.cache = cache
+	}
+}
+
+// New returns a Service backed by the given provider.
+func New(provider domain.Provider, opts ...Option) *Service {
+	svc := &Service{provider: provider}
+	for _, opt := range opts {
+		opt(svc)
+	}
+	return svc
+}
+
+// ListDomains returns all domains in the provider account.
+func (s *Service) ListDomains(ctx context.Context) ([]domain.Domain, error) {
+	if s.cache == nil {
+		return s.provider.ListDomains(ctx)
+	}
+
+	key := cacheKey(s.provider.GetDisplayName(), "domains")
+	return swrcache.GetOrFetch(s.cache, ctx, key, s.provider.ListDomains)
+}
+
+// ListRecords returns all DNS records for the given domain.
+func (s *Service) ListRecords(ctx context.Context, domainName string) ([]domain.Record, error) {
+	domainName = normalizeDomain(domainName)
+	if domainName == "" {
+		return nil, fmt.Errorf("domain name is required")
+	}
+	if s.cache == nil {
+		return s.provider.ListRecords(ctx, domainName)
+	}
+
+	key := cacheKey(s.provider.GetDisplayName(), "records", domainName)
+	return swrcache.GetOrFetch(s.cache, ctx, key, func(ctx context.Context) ([]domain.Record, error) {
+		return s.provider.ListRecords(ctx, domainName)
+	})
+}
+
+// GetRecord returns a single DNS record by domain and ID.
+func (s *Service) GetRecord(ctx context.Context, domainName string, id string) (*domain.Record, error) {
+	domainName = normalizeDomain(domainName)
+	if domainName == "" {
+		return nil, fmt.Errorf("domain name is required")
+	}
+	if id == "" {
+		return nil, fmt.Errorf("record ID is required")
+	}
+	return s.provider.GetRecord(ctx, domainName, id)
+}
+
+// CreateRecord creates a new DNS record after normalising and validating the opts.
+func (s *Service) CreateRecord(ctx context.Context, domainName string, opts domain.CreateRecordOpts) (*domain.Record, error) {
+	domainName = normalizeDomain(domainName)
+	if domainName == "" {
+		return nil, fmt.Errorf("domain name is required")
+	}
+
+	if err := validateRecordType(opts.Type); err != nil {
+		return nil, err
+	}
+	if err := validateContent(opts.Type, opts.Content); err != nil {
+		return nil, err
+	}
+
+	// Apply default TTL if none specified.
+	if opts.TTL <= 0 {
+		opts.TTL = DefaultTTL
+	}
+
+	// Normalise the subdomain portion.
+	opts.Name = normalizeSubdomain(opts.Name, domainName)
+
+	record, err := s.provider.CreateRecord(ctx, domainName, opts)
+	if err == nil && s.cache != nil {
+		_ = s.cache.Invalidate(cacheKey(s.provider.GetDisplayName(), "records", domainName))
+	}
+	return record, err
+}
+
+// UpdateRecord updates an existing DNS record after normalising and validating opts.
+func (s *Service) UpdateRecord(ctx context.Context, domainName string, id string, opts domain.UpdateRecordOpts) error {
+	domainName = normalizeDomain(domainName)
+	if domainName == "" {
+		return fmt.Errorf("domain name is required")
+	}
+	if id == "" {
+		return fmt.Errorf("record ID is required")
+	}
+
+	if opts.Type != "" {
+		if err := validateRecordType(opts.Type); err != nil {
+			return err
+		}
+	}
+	if opts.Content != "" {
+		if err := validateContent(opts.Type, opts.Content); err != nil {
+			return err
+		}
+	}
+
+	if opts.TTL <= 0 {
+		opts.TTL = DefaultTTL
+	}
+
+	if opts.Name != "" {
+		opts.Name = normalizeSubdomain(opts.Name, domainName)
+	}
+
+	err := s.provider.UpdateRecord(ctx, domainName, id, opts)
+	if err == nil && s.cache != nil {
+		_ = s.cache.Invalidate(cacheKey(s.provider.GetDisplayName(), "records", domainName))
+	}
+	return err
+}
+
+// DeleteRecord deletes a DNS record by domain and ID.
+func (s *Service) DeleteRecord(ctx context.Context, domainName string, id string) error {
+	domainName = normalizeDomain(domainName)
+	if domainName == "" {
+		return fmt.Errorf("domain name is required")
+	}
+	if id == "" {
+		return fmt.Errorf("record ID is required")
+	}
+	err := s.provider.DeleteRecord(ctx, domainName, id)
+	if err == nil && s.cache != nil {
+		_ = s.cache.Invalidate(cacheKey(s.provider.GetDisplayName(), "records", domainName))
+	}
+	return err
+}
diff --git a/internal/dns/services/service_test.go b/internal/dns/services/service_test.go
new file mode 100644
index 0000000..45a86e7
--- /dev/null
+++ b/internal/dns/services/service_test.go
@@ -0,0 +1,338 @@
+package services
+
+import (
+	"context"
+	"errors"
+	"testing"
+
+	"nathanbeddoewebdev/vpsm/internal/dns/domain"
+)
+
+// --- Mock provider ---
+
+type mockProvider struct {
+	domains        []domain.Domain
+	records        []domain.Record
+	listDomainsErr error
+	listRecordsErr error
+	getRecordErr   error
+	createErr      error
+	updateErr      error
+	deleteErr      error
+
+	// Capture arguments for assertion.
+	lastCreateOpts domain.CreateRecordOpts
+	lastUpdateOpts domain.UpdateRecordOpts
+	lastDomain     string
+	lastID         string
+}
+
+func (m *mockProvider) GetDisplayName() string { return "Mock" }
+
+func (m *mockProvider) ListDomains(_ context.Context) ([]domain.Domain, error) {
+	return m.domains, m.listDomainsErr
+}
+
+func (m *mockProvider) ListRecords(_ context.Context, d string) ([]domain.Record, error) {
+	m.lastDomain = d
+	return m.records, m.listRecordsErr
+}
+
+func (m *mockProvider) GetRecord(_ context.Context, d string, id string) (*domain.Record, error) {
+	m.lastDomain = d
+	m.lastID = id
+	if m.getRecordErr != nil {
+		return nil, m.getRecordErr
+	}
+	if len(m.records) == 0 {
+		return nil, domain.ErrNotFound
+	}
+	return &m.records[0], nil
+}
+
+func (m *mockProvider) CreateRecord(_ context.Context, d string, opts domain.CreateRecordOpts) (*domain.Record, error) {
+	m.lastDomain = d
+	m.lastCreateOpts = opts
+	if m.createErr != nil {
+		return nil, m.createErr
+	}
+	rec := domain.Record{
+		ID:      "new-id",
+		Domain:  d,
+		Name:    opts.Name,
+		Type:    opts.Type,
+		Content: opts.Content,
+		TTL:     opts.TTL,
+	}
+	return &rec, nil
+}
+
+func (m *mockProvider) UpdateRecord(_ context.Context, d string, id string, opts domain.UpdateRecordOpts) error {
+	m.lastDomain = d
+	m.lastID = id
+	m.lastUpdateOpts = opts
+	return m.updateErr
+}
+
+func (m *mockProvider) DeleteRecord(_ context.Context, d string, id string) error {
+	m.lastDomain = d
+	m.lastID = id
+	return m.deleteErr
+}
+
+// --- ListRecords tests ---
+
+func TestService_ListRecords_NormalizesDomain(t *testing.T) {
+	mock := &mockProvider{}
+	svc := New(mock)
+
+	_, _ = svc.ListRecords(context.Background(), "  EXAMPLE.COM.  ")
+
+	if mock.lastDomain != "example.com" {
+		t.Errorf("lastDomain = %q, want %q", mock.lastDomain, "example.com")
+	}
+}
+
+func TestService_ListRecords_EmptyDomain(t *testing.T) {
+	svc := New(&mockProvider{})
+	_, err := svc.ListRecords(context.Background(), "")
+	if err == nil {
+		t.Fatal("expected error for empty domain, got nil")
+	}
+}
+
+func TestService_ListRecords_PropagatesProviderError(t *testing.T) {
+	want := errors.New("provider down")
+	svc := New(&mockProvider{listRecordsErr: want})
+
+	_, err := svc.ListRecords(context.Background(), "example.com")
+	if !errors.Is(err, want) {
+		t.Errorf("expected provider error to propagate, got: %v", err)
+	}
+}
+
+// --- CreateRecord tests ---
+
+func TestService_CreateRecord_AppliesDefaultTTL(t *testing.T) {
+	mock := &mockProvider{}
+	svc := New(mock)
+
+	_, err := svc.CreateRecord(context.Background(), "example.com", domain.CreateRecordOpts{
+		Type:    domain.RecordTypeA,
+		Content: "1.2.3.4",
+		TTL:     0, // should become DefaultTTL
+	})
+	if err != nil {
+		t.Fatalf("expected no error, got %v", err)
+	}
+	if mock.lastCreateOpts.TTL != DefaultTTL {
+		t.Errorf("TTL = %d, want %d", mock.lastCreateOpts.TTL, DefaultTTL)
+	}
+}
+
+func TestService_CreateRecord_StripsFQDNSubdomain(t *testing.T) {
+	mock := &mockProvider{}
+	svc := New(mock)
+
+	_, err := svc.CreateRecord(context.Background(), "example.com", domain.CreateRecordOpts{
+		Name:    "www.example.com", // FQDN  should be stripped to "www"
+		Type:    domain.RecordTypeA,
+		Content: "1.2.3.4",
+	})
+	if err != nil {
+		t.Fatalf("expected no error, got %v", err)
+	}
+	if mock.lastCreateOpts.Name != "www" {
+		t.Errorf("Name = %q, want %q", mock.lastCreateOpts.Name, "www")
+	}
+}
+
+func TestService_CreateRecord_InvalidRecordType(t *testing.T) {
+	svc := New(&mockProvider{})
+
+	_, err := svc.CreateRecord(context.Background(), "example.com", domain.CreateRecordOpts{
+		Type:    "BOGUS",
+		Content: "1.2.3.4",
+	})
+	if err == nil {
+		t.Fatal("expected error for invalid record type, got nil")
+	}
+}
+
+func TestService_CreateRecord_InvalidARecordContent(t *testing.T) {
+	svc := New(&mockProvider{})
+
+	_, err := svc.CreateRecord(context.Background(), "example.com", domain.CreateRecordOpts{
+		Type:    domain.RecordTypeA,
+		Content: "not-an-ip",
+	})
+	if err == nil {
+		t.Fatal("expected error for non-IP A record content, got nil")
+	}
+}
+
+func TestService_CreateRecord_InvalidAAAAContent(t *testing.T) {
+	svc := New(&mockProvider{})
+
+	_, err := svc.CreateRecord(context.Background(), "example.com", domain.CreateRecordOpts{
+		Type:    domain.RecordTypeAAAA,
+		Content: "1.2.3.4", // IPv4 is not valid for AAAA
+	})
+	if err == nil {
+		t.Fatal("expected error for IPv4 in AAAA record, got nil")
+	}
+}
+
+func TestService_CreateRecord_ValidAAAA(t *testing.T) {
+	mock := &mockProvider{}
+	svc := New(mock)
+
+	_, err := svc.CreateRecord(context.Background(), "example.com", domain.CreateRecordOpts{
+		Type:    domain.RecordTypeAAAA,
+		Content: "2001:db8::1",
+	})
+	if err != nil {
+		t.Fatalf("expected no error for valid AAAA, got %v", err)
+	}
+}
+
+func TestService_CreateRecord_NormalizesDomain(t *testing.T) {
+	mock := &mockProvider{}
+	svc := New(mock)
+
+	_, _ = svc.CreateRecord(context.Background(), "EXAMPLE.COM.", domain.CreateRecordOpts{
+		Type:    domain.RecordTypeA,
+		Content: "1.2.3.4",
+	})
+	if mock.lastDomain != "example.com" {
+		t.Errorf("lastDomain = %q, want %q", mock.lastDomain, "example.com")
+	}
+}
+
+func TestService_CreateRecord_EmptyContent(t *testing.T) {
+	svc := New(&mockProvider{})
+
+	_, err := svc.CreateRecord(context.Background(), "example.com", domain.CreateRecordOpts{
+		Type:    domain.RecordTypeA,
+		Content: "",
+	})
+	if err == nil {
+		t.Fatal("expected error for empty content, got nil")
+	}
+}
+
+// --- UpdateRecord tests ---
+
+func TestService_UpdateRecord_PassesNormalizedInputs(t *testing.T) {
+	mock := &mockProvider{}
+	svc := New(mock)
+
+	err := svc.UpdateRecord(context.Background(), "EXAMPLE.COM.", "101", domain.UpdateRecordOpts{
+		Type:    domain.RecordTypeA,
+		Content: "9.9.9.9",
+		Name:    "www.example.com", // FQDN subdomain should be stripped
+	})
+	if err != nil {
+		t.Fatalf("expected no error, got %v", err)
+	}
+	if mock.lastDomain != "example.com" {
+		t.Errorf("lastDomain = %q, want %q", mock.lastDomain, "example.com")
+	}
+	if mock.lastUpdateOpts.Name != "www" {
+		t.Errorf("opts.Name = %q, want %q", mock.lastUpdateOpts.Name, "www")
+	}
+}
+
+func TestService_UpdateRecord_EmptyID(t *testing.T) {
+	svc := New(&mockProvider{})
+
+	err := svc.UpdateRecord(context.Background(), "example.com", "", domain.UpdateRecordOpts{
+		Type:    domain.RecordTypeA,
+		Content: "1.1.1.1",
+	})
+	if err == nil {
+		t.Fatal("expected error for empty ID, got nil")
+	}
+}
+
+// --- DeleteRecord tests ---
+
+func TestService_DeleteRecord_PassesNormalizedDomain(t *testing.T) {
+	mock := &mockProvider{}
+	svc := New(mock)
+
+	err := svc.DeleteRecord(context.Background(), "EXAMPLE.COM.", "101")
+	if err != nil {
+		t.Fatalf("expected no error, got %v", err)
+	}
+	if mock.lastDomain != "example.com" {
+		t.Errorf("lastDomain = %q, want %q", mock.lastDomain, "example.com")
+	}
+	if mock.lastID != "101" {
+		t.Errorf("lastID = %q, want %q", mock.lastID, "101")
+	}
+}
+
+func TestService_DeleteRecord_EmptyDomain(t *testing.T) {
+	svc := New(&mockProvider{})
+
+	err := svc.DeleteRecord(context.Background(), "", "101")
+	if err == nil {
+		t.Fatal("expected error for empty domain, got nil")
+	}
+}
+
+func TestService_DeleteRecord_EmptyID(t *testing.T) {
+	svc := New(&mockProvider{})
+
+	err := svc.DeleteRecord(context.Background(), "example.com", "")
+	if err == nil {
+		t.Fatal("expected error for empty ID, got nil")
+	}
+}
+
+// --- normalizeDomain tests ---
+
+func TestNormalizeDomain(t *testing.T) {
+	cases := []struct {
+		input string
+		want  string
+	}{
+		{"example.com", "example.com"},
+		{"EXAMPLE.COM", "example.com"},
+		{"example.com.", "example.com"},
+		{"  example.com.  ", "example.com"},
+		{"", ""},
+	}
+
+	for _, c := range cases {
+		got := normalizeDomain(c.input)
+		if got != c.want {
+			t.Errorf("normalizeDomain(%q) = %q, want %q", c.input, got, c.want)
+		}
+	}
+}
+
+// --- normalizeSubdomain tests ---
+
+func TestNormalizeSubdomain(t *testing.T) {
+	cases := []struct {
+		sub    string
+		domain string
+		want   string
+	}{
+		{"www", "example.com", "www"},
+		{"www.example.com", "example.com", "www"},
+		{"example.com", "example.com", ""},
+		{"", "example.com", ""},
+		{"WWW", "example.com", "www"},
+		{"mail.example.com.", "example.com", "mail"},
+	}
+
+	for _, c := range cases {
+		got := normalizeSubdomain(c.sub, c.domain)
+		if got != c.want {
+			t.Errorf("normalizeSubdomain(%q, %q) = %q, want %q", c.sub, c.domain, got, c.want)
+		}
+	}
+}
diff --git a/internal/dns/services/validate.go b/internal/dns/services/validate.go
new file mode 100644
index 0000000..cb16cb5
--- /dev/null
+++ b/internal/dns/services/validate.go
@@ -0,0 +1,87 @@
+package services
+
+import (
+	"fmt"
+	"net"
+	"strings"
+
+	"nathanbeddoewebdev/vpsm/internal/dns/domain"
+)
+
+// DefaultTTL is the TTL applied when none is specified (matches Porkbun's minimum).
+const DefaultTTL = 600
+
+// validRecordTypes is the set of supported DNS record types.
+var validRecordTypes = map[domain.RecordType]bool{
+	domain.RecordTypeA:     true,
+	domain.RecordTypeAAAA:  true,
+	domain.RecordTypeCNAME: true,
+	domain.RecordTypeAlias: true,
+	domain.RecordTypeTXT:   true,
+	domain.RecordTypeNS:    true,
+	domain.RecordTypeMX:    true,
+	domain.RecordTypeSRV:   true,
+	domain.RecordTypeTLSA:  true,
+	domain.RecordTypeCAA:   true,
+	domain.RecordTypeHTTPS: true,
+	domain.RecordTypeSVCB:  true,
+	domain.RecordTypeSSHFP: true,
+}
+
+// normalizeDomain lowercases and strips any trailing dot from a domain name.
+func normalizeDomain(d string) string {
+	return strings.ToLower(strings.TrimRight(strings.TrimSpace(d), "."))
+}
+
+// normalizeSubdomain strips the root domain suffix from a subdomain if the
+// user accidentally passes a fully-qualified name (e.g. "www.example.com"
+// when the domain is "example.com"), and lowercases the result.
+func normalizeSubdomain(sub, domainName string) string {
+	sub = strings.TrimSpace(sub)
+	sub = strings.TrimRight(sub, ".")
+	sub = strings.ToLower(sub)
+
+	// Strip ".domainName" suffix if present.
+	suffix := "." + domainName
+	if strings.HasSuffix(sub, suffix) {
+		sub = sub[:len(sub)-len(suffix)]
+	}
+	// Also strip if the caller passed the bare domain as the subdomain.
+	if sub == domainName {
+		sub = ""
+	}
+
+	return sub
+}
+
+// validateRecordType returns an error if t is not a supported record type.
+func validateRecordType(t domain.RecordType) error {
+	if !validRecordTypes[t] {
+		return fmt.Errorf("unsupported record type %q", t)
+	}
+	return nil
+}
+
+// validateContent checks that the content value is appropriate for the record type.
+// It does not perform exhaustive validation  it catches obvious mismatches
+// (e.g. a non-IP value for an A record) to give the user an early error.
+func validateContent(t domain.RecordType, content string) error {
+	if strings.TrimSpace(content) == "" {
+		return fmt.Errorf("record content cannot be empty")
+	}
+
+	switch t {
+	case domain.RecordTypeA:
+		ip := net.ParseIP(content)
+		if ip == nil || ip.To4() == nil {
+			return fmt.Errorf("A record content must be a valid IPv4 address, got %q", content)
+		}
+	case domain.RecordTypeAAAA:
+		ip := net.ParseIP(content)
+		if ip == nil || ip.To4() != nil {
+			return fmt.Errorf("AAAA record content must be a valid IPv6 address, got %q", content)
+		}
+	}
+
+	return nil
+}
diff --git a/internal/domain/create_opts.go b/internal/domain/create_opts.go
index 6917423..fa83b47 100644
--- a/internal/domain/create_opts.go
+++ b/internal/domain/create_opts.go
@@ -18,5 +18,5 @@ type CreateServerOpts struct {
 
 	// Provider-specific extensions (e.g. firewalls, networks, volumes).
 	// Keyed by provider-defined strings; see each provider for details.
-	Extra map[string]interface{}
+	Extra map[string]any
 }
diff --git a/internal/domain/server.go b/internal/domain/server.go
index 57369cc..12830a9 100644
--- a/internal/domain/server.go
+++ b/internal/domain/server.go
@@ -19,5 +19,5 @@ type Server struct {
 
 	// Metadata holds provider-specific fields
 	// Examples: floating_ips, firewalls, volumes, tags, etc.
-	Metadata map[string]interface{} `json:"metadata,omitempty"`
+	Metadata map[string]any `json:"metadata,omitempty"`
 }
diff --git a/internal/platform/providers/credentials.go b/internal/platform/providers/credentials.go
new file mode 100644
index 0000000..05a6b37
--- /dev/null
+++ b/internal/platform/providers/credentials.go
@@ -0,0 +1,89 @@
+// Package providers holds cross-domain provider metadata shared between
+// resource domains and the auth subsystem.
+package providers
+
+import "nathanbeddoewebdev/vpsm/internal/util"
+
+// CredentialKey describes a single credential field for a provider.
+type CredentialKey struct {
+	// Key is the suffix appended to the provider name to form the keychain key.
+	// For single-token providers this is empty (key stored as just "<provider>").
+	// For multi-credential providers this is set (e.g. "apikey", "secretapikey").
+	Key string
+
+	// Prompt is the human-readable label shown when prompting the user.
+	Prompt string
+
+	// Secret controls whether the input should be masked (e.g. passwords/tokens).
+	Secret bool
+}
+
+// CredentialSpec describes the complete credential scheme for a provider.
+type CredentialSpec struct {
+	// Provider is the normalized provider name (e.g. "hetzner", "porkbun").
+	Provider string
+
+	// DisplayName is the human-readable provider name (e.g. "Hetzner", "Porkbun").
+	DisplayName string
+
+	// Keys lists each credential that must be stored.
+	// Single-token providers have one entry with an empty Key.
+	// Multi-credential providers have one entry per credential.
+	Keys []CredentialKey
+}
+
+// KeychainKey returns the keychain key for the given CredentialKey.
+// For single-token providers (empty Key suffix), it returns the provider name.
+// For multi-credential providers it returns "<provider>-<key>".
+func (s CredentialSpec) KeychainKey(k CredentialKey) string {
+	if k.Key == "" {
+		return s.Provider
+	}
+	return s.Provider + "-" + k.Key
+}
+
+// knownSpecs is the authoritative list of registered provider credential specs.
+// The auth login command iterates this to know how to prompt for credentials.
+var knownSpecs = []CredentialSpec{
+	{
+		Provider:    "hetzner",
+		DisplayName: "Hetzner",
+		Keys: []CredentialKey{
+			{Key: "", Prompt: "API Token", Secret: true},
+		},
+	},
+	{
+		Provider:    "porkbun",
+		DisplayName: "Porkbun",
+		Keys: []CredentialKey{
+			{Key: "apikey", Prompt: "API Key", Secret: true},
+			{Key: "secretapikey", Prompt: "Secret API Key", Secret: true},
+		},
+	},
+	{
+		Provider:    "cloudflare",
+		DisplayName: "Cloudflare",
+		Keys: []CredentialKey{
+			{Key: "", Prompt: "Account API Token (not Global API Key)", Secret: true},
+		},
+	},
+}
+
+// Lookup returns the CredentialSpec for the given provider name,
+// or nil if no spec is registered for that provider.
+func Lookup(providerName string) *CredentialSpec {
+	normalized := util.NormalizeKey(providerName)
+	for i := range knownSpecs {
+		if knownSpecs[i].Provider == normalized {
+			return &knownSpecs[i]
+		}
+	}
+	return nil
+}
+
+// All returns a copy of all registered credential specs.
+func All() []CredentialSpec {
+	out := make([]CredentialSpec, len(knownSpecs))
+	copy(out, knownSpecs)
+	return out
+}
diff --git a/internal/providers/hetzner.go b/internal/providers/hetzner.go
index d37b7fb..53cf801 100644
--- a/internal/providers/hetzner.go
+++ b/internal/providers/hetzner.go
@@ -242,7 +242,7 @@ func toDomainServer(s *hcloud.Server) domain.Server {
 		Status:    string(s.Status),
 		CreatedAt: s.Created,
 		Provider:  "hetzner",
-		Metadata:  make(map[string]interface{}),
+		Metadata:  make(map[string]any),
 	}
 
 	if !s.PublicNet.IPv4.IsUnspecified() {
diff --git a/internal/providers/hetzner_catalog_test.go b/internal/providers/hetzner_catalog_test.go
index d248763..3cdeb95 100644
--- a/internal/providers/hetzner_catalog_test.go
+++ b/internal/providers/hetzner_catalog_test.go
@@ -15,8 +15,8 @@ import (
 // --- ListLocations tests ---
 
 func TestListLocations_HappyPath(t *testing.T) {
-	response := map[string]interface{}{
-		"locations": []interface{}{
+	response := map[string]any{
+		"locations": []any{
 			testLocationJSON(1, "fsn1", "DE", "Falkenstein"),
 			testLocationJSON(2, "nbg1", "DE", "Nuremberg"),
 			testLocationJSON(3, "ash", "US", "Ashburn"),
@@ -47,8 +47,8 @@ func TestListLocations_HappyPath(t *testing.T) {
 }
 
 func TestListLocations_EmptyList(t *testing.T) {
-	srv := newTestAPI(t, map[string]interface{}{
-		"locations": []interface{}{},
+	srv := newTestAPI(t, map[string]any{
+		"locations": []any{},
 	})
 	provider := newTestHetznerProvider(t, srv.URL, "test-token")
 
@@ -63,8 +63,8 @@ func TestListLocations_EmptyList(t *testing.T) {
 
 func TestListLocations_UsesCache(t *testing.T) {
 	callCount := 0
-	response := map[string]interface{}{
-		"locations": []interface{}{
+	response := map[string]any{
+		"locations": []any{
 			testLocationJSON(1, "fsn1", "DE", "Falkenstein"),
 		},
 	}
@@ -94,8 +94,8 @@ func TestListLocations_Non200(t *testing.T) {
 	srv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
 		w.Header().Set("Content-Type", "application/json")
 		w.WriteHeader(http.StatusUnauthorized)
-		json.NewEncoder(w).Encode(map[string]interface{}{
-			"error": map[string]interface{}{
+		json.NewEncoder(w).Encode(map[string]any{
+			"error": map[string]any{
 				"code":    "unauthorized",
 				"message": "unable to authenticate",
 			},
@@ -117,20 +117,20 @@ func TestListServerTypes_HappyPath(t *testing.T) {
 	st1["cores"] = 2
 	st1["memory"] = 2.0
 	st1["disk"] = 40
-	st1["locations"] = []interface{}{
+	st1["locations"] = []any{
 		testServerTypeLocationJSON(1, "fsn1", nil),
 		testServerTypeLocationJSON(2, "nbg1", nil),
 	}
-	st1["prices"] = []interface{}{
-		map[string]interface{}{
+	st1["prices"] = []any{
+		map[string]any{
 			"location":      "fsn1",
-			"price_hourly":  map[string]interface{}{"net": "0.0054", "gross": "0.0064"},
-			"price_monthly": map[string]interface{}{"net": "3.29", "gross": "3.92"},
+			"price_hourly":  map[string]any{"net": "0.0054", "gross": "0.0064"},
+			"price_monthly": map[string]any{"net": "3.29", "gross": "3.92"},
 		},
-		map[string]interface{}{
+		map[string]any{
 			"location":      "nbg1",
-			"price_hourly":  map[string]interface{}{"net": "0.0054", "gross": "0.0064"},
-			"price_monthly": map[string]interface{}{"net": "3.29", "gross": "3.92"},
+			"price_hourly":  map[string]any{"net": "0.0054", "gross": "0.0064"},
+			"price_monthly": map[string]any{"net": "3.29", "gross": "3.92"},
 		},
 	}
 
@@ -138,19 +138,19 @@ func TestListServerTypes_HappyPath(t *testing.T) {
 	st2["cores"] = 2
 	st2["memory"] = 4.0
 	st2["disk"] = 40
-	st2["locations"] = []interface{}{
+	st2["locations"] = []any{
 		testServerTypeLocationJSON(1, "fsn1", nil),
 	}
-	st2["prices"] = []interface{}{
-		map[string]interface{}{
+	st2["prices"] = []any{
+		map[string]any{
 			"location":      "fsn1",
-			"price_hourly":  map[string]interface{}{"net": "0.0046", "gross": "0.0055"},
-			"price_monthly": map[string]interface{}{"net": "2.69", "gross": "3.29"},
+			"price_hourly":  map[string]any{"net": "0.0046", "gross": "0.0055"},
+			"price_monthly": map[string]any{"net": "2.69", "gross": "3.29"},
 		},
 	}
 
-	response := map[string]interface{}{
-		"server_types": []interface{}{st1, st2},
+	response := map[string]any{
+		"server_types": []any{st1, st2},
 	}
 
 	srv := newTestAPI(t, response)
@@ -187,28 +187,28 @@ func TestListServerTypes_HappyPath(t *testing.T) {
 
 func TestListServerTypes_ExcludesDeprecatedLocations(t *testing.T) {
 	st := testServerTypeJSON(1, "cpx11", "x86")
-	st["locations"] = []interface{}{
-		testServerTypeLocationJSON(1, "fsn1", map[string]interface{}{
+	st["locations"] = []any{
+		testServerTypeLocationJSON(1, "fsn1", map[string]any{
 			"announced":         "2024-01-01T00:00:00+00:00",
 			"unavailable_after": "2024-06-01T00:00:00+00:00",
 		}),
 		testServerTypeLocationJSON(2, "nbg1", nil),
 	}
-	st["prices"] = []interface{}{
-		map[string]interface{}{
+	st["prices"] = []any{
+		map[string]any{
 			"location":      "fsn1",
-			"price_hourly":  map[string]interface{}{"net": "0.0054", "gross": "0.0064"},
-			"price_monthly": map[string]interface{}{"net": "3.29", "gross": "3.92"},
+			"price_hourly":  map[string]any{"net": "0.0054", "gross": "0.0064"},
+			"price_monthly": map[string]any{"net": "3.29", "gross": "3.92"},
 		},
-		map[string]interface{}{
+		map[string]any{
 			"location":      "nbg1",
-			"price_hourly":  map[string]interface{}{"net": "0.0054", "gross": "0.0064"},
-			"price_monthly": map[string]interface{}{"net": "3.29", "gross": "3.92"},
+			"price_hourly":  map[string]any{"net": "0.0054", "gross": "0.0064"},
+			"price_monthly": map[string]any{"net": "3.29", "gross": "3.92"},
 		},
 	}
 
-	response := map[string]interface{}{
-		"server_types": []interface{}{st},
+	response := map[string]any{
+		"server_types": []any{st},
 	}
 
 	srv := newTestAPI(t, response)
@@ -232,17 +232,17 @@ func TestListServerTypes_ExcludesDeprecatedLocations(t *testing.T) {
 
 func TestListServerTypes_FallsBackToPricesWhenNoLocations(t *testing.T) {
 	st := testServerTypeJSON(1, "cpx11", "x86")
-	st["locations"] = []interface{}{} // empty locations array
-	st["prices"] = []interface{}{
-		map[string]interface{}{
+	st["locations"] = []any{} // empty locations array
+	st["prices"] = []any{
+		map[string]any{
 			"location":      "fsn1",
-			"price_hourly":  map[string]interface{}{"net": "0.0054", "gross": "0.0064"},
-			"price_monthly": map[string]interface{}{"net": "3.29", "gross": "3.92"},
+			"price_hourly":  map[string]any{"net": "0.0054", "gross": "0.0064"},
+			"price_monthly": map[string]any{"net": "3.29", "gross": "3.92"},
 		},
 	}
 
-	response := map[string]interface{}{
-		"server_types": []interface{}{st},
+	response := map[string]any{
+		"server_types": []any{st},
 	}
 
 	srv := newTestAPI(t, response)
@@ -267,8 +267,8 @@ func TestListServerTypes_NoPrices(t *testing.T) {
 	st := testServerTypeJSON(1, "cpx11", "x86")
 	// prices is already an empty array from the helper
 
-	response := map[string]interface{}{
-		"server_types": []interface{}{st},
+	response := map[string]any{
+		"server_types": []any{st},
 	}
 
 	srv := newTestAPI(t, response)
@@ -292,8 +292,8 @@ func TestListServerTypes_NoPrices(t *testing.T) {
 }
 
 func TestListServerTypes_EmptyList(t *testing.T) {
-	srv := newTestAPI(t, map[string]interface{}{
-		"server_types": []interface{}{},
+	srv := newTestAPI(t, map[string]any{
+		"server_types": []any{},
 	})
 	provider := newTestHetznerProvider(t, srv.URL, "test-token")
 
@@ -310,8 +310,8 @@ func TestListServerTypes_Non200(t *testing.T) {
 	srv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
 		w.Header().Set("Content-Type", "application/json")
 		w.WriteHeader(http.StatusInternalServerError)
-		json.NewEncoder(w).Encode(map[string]interface{}{
-			"error": map[string]interface{}{
+		json.NewEncoder(w).Encode(map[string]any{
+			"error": map[string]any{
 				"code":    "server_error",
 				"message": "internal error",
 			},
@@ -329,8 +329,8 @@ func TestListServerTypes_Non200(t *testing.T) {
 // --- ListImages tests ---
 
 func TestListImages_HappyPath(t *testing.T) {
-	response := map[string]interface{}{
-		"images": []interface{}{
+	response := map[string]any{
+		"images": []any{
 			testImageJSON(114690387, "ubuntu-24.04", "ubuntu", "24.04", "x86"),
 			testImageJSON(114690389, "debian-12", "debian", "12", "x86"),
 		},
@@ -359,8 +359,8 @@ func TestListImages_HappyPath(t *testing.T) {
 }
 
 func TestListImages_EmptyList(t *testing.T) {
-	srv := newTestAPI(t, map[string]interface{}{
-		"images": []interface{}{},
+	srv := newTestAPI(t, map[string]any{
+		"images": []any{},
 	})
 	provider := newTestHetznerProvider(t, srv.URL, "test-token")
 
@@ -377,8 +377,8 @@ func TestListImages_Non200(t *testing.T) {
 	srv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
 		w.Header().Set("Content-Type", "application/json")
 		w.WriteHeader(http.StatusForbidden)
-		json.NewEncoder(w).Encode(map[string]interface{}{
-			"error": map[string]interface{}{
+		json.NewEncoder(w).Encode(map[string]any{
+			"error": map[string]any{
 				"code":    "forbidden",
 				"message": "insufficient permissions",
 			},
@@ -395,20 +395,20 @@ func TestListImages_Non200(t *testing.T) {
 
 // --- ListSSHKeys tests ---
 
-func testSSHKeyJSON(id int, name, fingerprint, publicKey string) map[string]interface{} {
-	return map[string]interface{}{
+func testSSHKeyJSON(id int, name, fingerprint, publicKey string) map[string]any {
+	return map[string]any{
 		"id":          id,
 		"name":        name,
 		"fingerprint": fingerprint,
 		"public_key":  publicKey,
-		"labels":      map[string]interface{}{},
+		"labels":      map[string]any{},
 		"created":     "2024-01-01T00:00:00+00:00",
 	}
 }
 
 func TestListSSHKeys_HappyPath(t *testing.T) {
-	response := map[string]interface{}{
-		"ssh_keys": []interface{}{
+	response := map[string]any{
+		"ssh_keys": []any{
 			testSSHKeyJSON(1, "my-key", "b7:2f:30:a0:2f:6c:58:6c:21:04:58:61:ba:06:3b:2f", "ssh-rsa AAAA..."),
 			testSSHKeyJSON(2, "deploy-key", "a1:b2:c3:d4:e5:f6:00:11:22:33:44:55:66:77:88:99", "ssh-ed25519 AAAA..."),
 		},
@@ -437,8 +437,8 @@ func TestListSSHKeys_HappyPath(t *testing.T) {
 }
 
 func TestListSSHKeys_EmptyList(t *testing.T) {
-	srv := newTestAPI(t, map[string]interface{}{
-		"ssh_keys": []interface{}{},
+	srv := newTestAPI(t, map[string]any{
+		"ssh_keys": []any{},
 	})
 	provider := newTestHetznerProvider(t, srv.URL, "test-token")
 
@@ -455,8 +455,8 @@ func TestListSSHKeys_Non200(t *testing.T) {
 	srv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
 		w.Header().Set("Content-Type", "application/json")
 		w.WriteHeader(http.StatusUnauthorized)
-		json.NewEncoder(w).Encode(map[string]interface{}{
-			"error": map[string]interface{}{
+		json.NewEncoder(w).Encode(map[string]any{
+			"error": map[string]any{
 				"code":    "unauthorized",
 				"message": "unable to authenticate",
 			},
@@ -482,7 +482,7 @@ func TestCreateSSHKey_HappyPath(t *testing.T) {
 			t.Errorf("expected path /ssh_keys, got %s", r.URL.Path)
 		}
 
-		var req map[string]interface{}
+		var req map[string]any
 		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
 			t.Fatalf("failed to decode request: %v", err)
 		}
@@ -495,7 +495,7 @@ func TestCreateSSHKey_HappyPath(t *testing.T) {
 		}
 
 		w.Header().Set("Content-Type", "application/json")
-		json.NewEncoder(w).Encode(map[string]interface{}{
+		json.NewEncoder(w).Encode(map[string]any{
 			"ssh_key": testSSHKeyJSON(42, "my-laptop", "aa:bb:cc:dd:ee:ff:00:11:22:33:44:55:66:77:88:99", "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5..."),
 		})
 	}))
@@ -522,8 +522,8 @@ func TestCreateSSHKey_DuplicateName(t *testing.T) {
 	srv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
 		w.Header().Set("Content-Type", "application/json")
 		w.WriteHeader(http.StatusConflict)
-		json.NewEncoder(w).Encode(map[string]interface{}{
-			"error": map[string]interface{}{
+		json.NewEncoder(w).Encode(map[string]any{
+			"error": map[string]any{
 				"code":    "conflict",
 				"message": "SSH key with this name already exists",
 			},
@@ -542,8 +542,8 @@ func TestCreateSSHKey_Unauthorized(t *testing.T) {
 	srv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
 		w.Header().Set("Content-Type", "application/json")
 		w.WriteHeader(http.StatusUnauthorized)
-		json.NewEncoder(w).Encode(map[string]interface{}{
-			"error": map[string]interface{}{
+		json.NewEncoder(w).Encode(map[string]any{
+			"error": map[string]any{
 				"code":    "unauthorized",
 				"message": "unable to authenticate",
 			},
@@ -600,11 +600,11 @@ func TestCatalogMethods_RequestPaths(t *testing.T) {
 
 				// Return a valid empty response for each endpoint.
 				w.Header().Set("Content-Type", "application/json")
-				json.NewEncoder(w).Encode(map[string]interface{}{
-					"locations":    []interface{}{},
-					"server_types": []interface{}{},
-					"images":       []interface{}{},
-					"ssh_keys":     []interface{}{},
+				json.NewEncoder(w).Encode(map[string]any{
+					"locations":    []any{},
+					"server_types": []any{},
+					"images":       []any{},
+					"ssh_keys":     []any{},
 				})
 			}))
 			t.Cleanup(srv.Close)
diff --git a/internal/providers/hetzner_metrics.go b/internal/providers/hetzner_metrics.go
index 30ff3fd..10062b1 100644
--- a/internal/providers/hetzner_metrics.go
+++ b/internal/providers/hetzner_metrics.go
@@ -33,10 +33,7 @@ func (h *HetznerProvider) GetServerMetrics(ctx context.Context, serverID string,
 
 	// Calculate step to produce ~60 data points.
 	duration := end.Sub(start)
-	step := int(duration.Seconds() / 60)
-	if step < 1 {
-		step = 1
-	}
+	step := max(int(duration.Seconds()/60), 1)
 
 	opts := hcloud.ServerGetMetricsOpts{
 		Types: hcloudTypes,
diff --git a/internal/providers/hetzner_metrics_test.go b/internal/providers/hetzner_metrics_test.go
index afeaa17..ded0229 100644
--- a/internal/providers/hetzner_metrics_test.go
+++ b/internal/providers/hetzner_metrics_test.go
@@ -17,20 +17,20 @@ import (
 // testMetricsResponse builds a Hetzner API metrics response with the given
 // time series data. Keys follow the Hetzner API naming (e.g. "cpu",
 // "disk.0.iops.read", "network.0.bandwidth.in").
-func testMetricsResponse(start, end string, step float64, timeSeries map[string][][2]interface{}) map[string]interface{} {
-	ts := make(map[string]interface{}, len(timeSeries))
+func testMetricsResponse(start, end string, step float64, timeSeries map[string][][2]any) map[string]any {
+	ts := make(map[string]any, len(timeSeries))
 	for name, points := range timeSeries {
-		values := make([]interface{}, len(points))
+		values := make([]any, len(points))
 		for i, pt := range points {
-			values[i] = []interface{}{pt[0], pt[1]}
+			values[i] = []any{pt[0], pt[1]}
 		}
-		ts[name] = map[string]interface{}{
+		ts[name] = map[string]any{
 			"values": values,
 		}
 	}
 
-	return map[string]interface{}{
-		"metrics": map[string]interface{}{
+	return map[string]any{
+		"metrics": map[string]any{
 			"start":       start,
 			"end":         end,
 			"step":        step,
@@ -44,7 +44,7 @@ func TestGetServerMetrics_HappyPath(t *testing.T) {
 		"2024-01-15T12:00:00Z",
 		"2024-01-15T13:00:00Z",
 		60,
-		map[string][][2]interface{}{
+		map[string][][2]any{
 			"cpu": {
 				{1705320000.0, "42.5"},
 				{1705320060.0, "55.3"},
@@ -161,7 +161,7 @@ func TestGetServerMetrics_HappyPath(t *testing.T) {
 }
 
 func TestGetServerMetrics_InvalidID(t *testing.T) {
-	srv := newTestAPI(t, map[string]interface{}{})
+	srv := newTestAPI(t, map[string]any{})
 	provider := newTestHetznerProvider(t, srv.URL, "test-token")
 
 	_, err := provider.GetServerMetrics(
@@ -183,8 +183,8 @@ func TestGetServerMetrics_NotFound(t *testing.T) {
 	srv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
 		w.Header().Set("Content-Type", "application/json")
 		w.WriteHeader(http.StatusNotFound)
-		json.NewEncoder(w).Encode(map[string]interface{}{
-			"error": map[string]interface{}{
+		json.NewEncoder(w).Encode(map[string]any{
+			"error": map[string]any{
 				"code":    "not_found",
 				"message": "server not found",
 			},
@@ -213,8 +213,8 @@ func TestGetServerMetrics_Unauthorized(t *testing.T) {
 	srv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
 		w.Header().Set("Content-Type", "application/json")
 		w.WriteHeader(http.StatusUnauthorized)
-		json.NewEncoder(w).Encode(map[string]interface{}{
-			"error": map[string]interface{}{
+		json.NewEncoder(w).Encode(map[string]any{
+			"error": map[string]any{
 				"code":    "unauthorized",
 				"message": "unable to authenticate",
 			},
@@ -244,7 +244,7 @@ func TestGetServerMetrics_EmptySeries(t *testing.T) {
 		"2024-01-15T12:00:00Z",
 		"2024-01-15T13:00:00Z",
 		60,
-		map[string][][2]interface{}{
+		map[string][][2]any{
 			"cpu": {},
 		},
 	)
diff --git a/internal/providers/hetzner_test.go b/internal/providers/hetzner_test.go
index bfc7e2f..c0c8f35 100644
--- a/internal/providers/hetzner_test.go
+++ b/internal/providers/hetzner_test.go
@@ -36,7 +36,7 @@ func newTestHetznerProvider(t *testing.T, serverURL string, token string) *Hetzn
 
 // newTestAPI spins up an httptest.Server that returns the given response as JSON.
 // The server is automatically closed when the test finishes.
-func newTestAPI(t *testing.T, response interface{}) *httptest.Server {
+func newTestAPI(t *testing.T, response any) *httptest.Server {
 	t.Helper()
 	srv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
 		w.Header().Set("Content-Type", "application/json")
@@ -51,8 +51,8 @@ func newTestAPI(t *testing.T, response interface{}) *httptest.Server {
 // --- JSON builder helpers for Hetzner API-shaped responses ---
 
 // testLocationJSON builds a Hetzner API location object.
-func testLocationJSON(id int, name, country, city string) map[string]interface{} {
-	return map[string]interface{}{
+func testLocationJSON(id int, name, country, city string) map[string]any {
+	return map[string]any{
 		"id": id, "name": name, "description": name,
 		"country": country, "city": city,
 		"latitude": 50.0, "longitude": 12.0,
@@ -61,22 +61,22 @@ func testLocationJSON(id int, name, country, city string) map[string]interface{}
 }
 
 // testServerTypeJSON builds a Hetzner API server_type object.
-func testServerTypeJSON(id int, name, arch string) map[string]interface{} {
-	return map[string]interface{}{
+func testServerTypeJSON(id int, name, arch string) map[string]any {
+	return map[string]any{
 		"id": id, "name": name, "description": name,
 		"cores": 2, "memory": 2.0, "disk": 40,
 		"architecture": arch,
 		"storage_type": "local",
 		"cpu_type":     "shared",
-		"prices":       []interface{}{},
-		"locations":    []interface{}{},
+		"prices":       []any{},
+		"locations":    []any{},
 	}
 }
 
 // testServerTypeLocationJSON builds a Hetzner API server_type location entry,
 // optionally with deprecation info.
-func testServerTypeLocationJSON(id int, name string, deprecation map[string]interface{}) map[string]interface{} {
-	loc := map[string]interface{}{
+func testServerTypeLocationJSON(id int, name string, deprecation map[string]any) map[string]any {
+	loc := map[string]any{
 		"id":   id,
 		"name": name,
 	}
@@ -87,8 +87,8 @@ func testServerTypeLocationJSON(id int, name string, deprecation map[string]inte
 }
 
 // testImageJSON builds a Hetzner API image object.
-func testImageJSON(id int, name, osFlavor, osVersion, arch string) map[string]interface{} {
-	return map[string]interface{}{
+func testImageJSON(id int, name, osFlavor, osVersion, arch string) map[string]any {
+	return map[string]any{
 		"id": id, "name": name, "description": name,
 		"type": "system", "status": "available",
 		"os_flavor": osFlavor, "os_version": osVersion,
@@ -98,23 +98,23 @@ func testImageJSON(id int, name, osFlavor, osVersion, arch string) map[string]in
 
 // testServerJSON builds a minimal Hetzner API server object with sensible defaults.
 // The returned map can be modified before being used in a response.
-func testServerJSON(id int, name, status, created string, loc map[string]interface{}, st map[string]interface{}) map[string]interface{} {
-	return map[string]interface{}{
+func testServerJSON(id int, name, status, created string, loc map[string]any, st map[string]any) map[string]any {
+	return map[string]any{
 		"id":      id,
 		"name":    name,
 		"status":  status,
 		"created": created,
-		"public_net": map[string]interface{}{
-			"floating_ips": []interface{}{},
-			"firewalls":    []interface{}{},
+		"public_net": map[string]any{
+			"floating_ips": []any{},
+			"firewalls":    []any{},
 		},
-		"private_net":    []interface{}{},
+		"private_net":    []any{},
 		"server_type":    st,
 		"image":          nil,
 		"location":       loc,
-		"labels":         map[string]interface{}{},
-		"volumes":        []interface{}{},
-		"load_balancers": []interface{}{},
+		"labels":         map[string]any{},
+		"volumes":        []any{},
+		"load_balancers": []any{},
 	}
 }
 
@@ -130,27 +130,27 @@ func TestListServers_HappyPath(t *testing.T) {
 	nbg1 := testLocationJSON(2, "nbg1", "DE", "Nuremberg")
 
 	server1 := testServerJSON(42, "web-server", "running", createdStr, fsn1, testServerTypeJSON(1, "cpx11", "x86"))
-	server1["public_net"] = map[string]interface{}{
-		"ipv4":         map[string]interface{}{"ip": "1.2.3.4", "blocked": false},
-		"ipv6":         map[string]interface{}{"ip": "2001:db8::/64", "blocked": false},
-		"floating_ips": []interface{}{},
-		"firewalls":    []interface{}{},
+	server1["public_net"] = map[string]any{
+		"ipv4":         map[string]any{"ip": "1.2.3.4", "blocked": false},
+		"ipv6":         map[string]any{"ip": "2001:db8::/64", "blocked": false},
+		"floating_ips": []any{},
+		"firewalls":    []any{},
 	}
-	server1["private_net"] = []interface{}{
-		map[string]interface{}{"ip": "10.0.0.2", "alias_ips": []interface{}{}, "network": 1, "mac_address": ""},
+	server1["private_net"] = []any{
+		map[string]any{"ip": "10.0.0.2", "alias_ips": []any{}, "network": 1, "mac_address": ""},
 	}
 	server1["image"] = testImageJSON(1, "ubuntu-24.04", "ubuntu", "24.04", "x86")
 
 	server2 := testServerJSON(99, "db-server", "stopped", createdStr, nbg1, testServerTypeJSON(2, "cpx22", "arm"))
-	server2["public_net"] = map[string]interface{}{
-		"ipv4":         map[string]interface{}{"ip": "5.6.7.8", "blocked": false},
-		"floating_ips": []interface{}{},
-		"firewalls":    []interface{}{},
+	server2["public_net"] = map[string]any{
+		"ipv4":         map[string]any{"ip": "5.6.7.8", "blocked": false},
+		"floating_ips": []any{},
+		"firewalls":    []any{},
 	}
 	server2["image"] = testImageJSON(2, "debian-12", "debian", "12", "x86")
 
-	response := map[string]interface{}{
-		"servers": []interface{}{server1, server2},
+	response := map[string]any{
+		"servers": []any{server1, server2},
 	}
 
 	srv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
@@ -189,7 +189,7 @@ func TestListServers_HappyPath(t *testing.T) {
 		ServerType:  "cpx11",
 		Image:       "ubuntu-24.04",
 		Provider:    "hetzner",
-		Metadata: map[string]interface{}{
+		Metadata: map[string]any{
 			"hetzner_id":   int64(42),
 			"architecture": "x86",
 		},
@@ -205,7 +205,7 @@ func TestListServers_HappyPath(t *testing.T) {
 		ServerType: "cpx22",
 		Image:      "debian-12",
 		Provider:   "hetzner",
-		Metadata: map[string]interface{}{
+		Metadata: map[string]any{
 			"hetzner_id":   int64(99),
 			"architecture": "arm",
 		},
@@ -220,8 +220,8 @@ func TestListServers_HappyPath(t *testing.T) {
 }
 
 func TestListServers_EmptyList(t *testing.T) {
-	srv := newTestAPI(t, map[string]interface{}{
-		"servers": []interface{}{},
+	srv := newTestAPI(t, map[string]any{
+		"servers": []any{},
 	})
 
 	ctx := context.Background()
@@ -247,16 +247,16 @@ func TestListServers_RetriesOnTransientError(t *testing.T) {
 		w.Header().Set("Content-Type", "application/json")
 		if callCount == 1 {
 			w.WriteHeader(http.StatusServiceUnavailable)
-			json.NewEncoder(w).Encode(map[string]interface{}{
-				"error": map[string]interface{}{
+			json.NewEncoder(w).Encode(map[string]any{
+				"error": map[string]any{
 					"code":    "service_error",
 					"message": "temporary error",
 				},
 			})
 			return
 		}
-		json.NewEncoder(w).Encode(map[string]interface{}{
-			"servers": []interface{}{server},
+		json.NewEncoder(w).Encode(map[string]any{
+			"servers": []any{server},
 		})
 	}))
 	t.Cleanup(srv.Close)
@@ -282,8 +282,8 @@ func TestListServers_NilOptionalFields(t *testing.T) {
 	// image is already nil from testServerJSON
 	// public_net has no ipv4/ipv6 entries, private_net is empty
 
-	srv := newTestAPI(t, map[string]interface{}{
-		"servers": []interface{}{server},
+	srv := newTestAPI(t, map[string]any{
+		"servers": []any{server},
 	})
 
 	ctx := context.Background()
@@ -315,8 +315,8 @@ func TestListServers_Non200StatusCode(t *testing.T) {
 	srv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
 		w.Header().Set("Content-Type", "application/json")
 		w.WriteHeader(http.StatusUnauthorized)
-		json.NewEncoder(w).Encode(map[string]interface{}{
-			"error": map[string]interface{}{
+		json.NewEncoder(w).Encode(map[string]any{
+			"error": map[string]any{
 				"code":    "unauthorized",
 				"message": "unable to authenticate",
 			},
@@ -352,8 +352,8 @@ func TestListServers_FactoryViaRegistry(t *testing.T) {
 
 	server := testServerJSON(7, "registry-server", "running", "2024-06-15T12:00:00+00:00", loc, testServerTypeJSON(3, "cpx31", "x86"))
 
-	response := map[string]interface{}{
-		"servers": []interface{}{server},
+	response := map[string]any{
+		"servers": []any{server},
 	}
 
 	srv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
@@ -432,11 +432,11 @@ func TestGetServer_HappyPath(t *testing.T) {
 	fsn1 := testLocationJSON(1, "fsn1", "DE", "Falkenstein")
 
 	server := testServerJSON(42, "web-server", "running", createdStr, fsn1, testServerTypeJSON(1, "cpx11", "x86"))
-	server["public_net"] = map[string]interface{}{
-		"ipv4":         map[string]interface{}{"ip": "1.2.3.4", "blocked": false},
-		"ipv6":         map[string]interface{}{"ip": "2001:db8::/64", "blocked": false},
-		"floating_ips": []interface{}{},
-		"firewalls":    []interface{}{},
+	server["public_net"] = map[string]any{
+		"ipv4":         map[string]any{"ip": "1.2.3.4", "blocked": false},
+		"ipv6":         map[string]any{"ip": "2001:db8::/64", "blocked": false},
+		"floating_ips": []any{},
+		"firewalls":    []any{},
 	}
 	server["image"] = testImageJSON(1, "ubuntu-24.04", "ubuntu", "24.04", "x86")
 
@@ -449,7 +449,7 @@ func TestGetServer_HappyPath(t *testing.T) {
 		}
 
 		w.Header().Set("Content-Type", "application/json")
-		json.NewEncoder(w).Encode(map[string]interface{}{
+		json.NewEncoder(w).Encode(map[string]any{
 			"server": server,
 		})
 	}))
@@ -473,7 +473,7 @@ func TestGetServer_HappyPath(t *testing.T) {
 		ServerType: "cpx11",
 		Image:      "ubuntu-24.04",
 		Provider:   "hetzner",
-		Metadata: map[string]interface{}{
+		Metadata: map[string]any{
 			"hetzner_id":   int64(42),
 			"architecture": "x86",
 		},
@@ -500,8 +500,8 @@ func TestGetServer_NotFound(t *testing.T) {
 	srv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
 		w.Header().Set("Content-Type", "application/json")
 		w.WriteHeader(http.StatusNotFound)
-		json.NewEncoder(w).Encode(map[string]interface{}{
-			"error": map[string]interface{}{
+		json.NewEncoder(w).Encode(map[string]any{
+			"error": map[string]any{
 				"code":    "not_found",
 				"message": "server with ID '999' not found",
 			},
@@ -524,8 +524,8 @@ func TestGetServer_Unauthorized(t *testing.T) {
 	srv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
 		w.Header().Set("Content-Type", "application/json")
 		w.WriteHeader(http.StatusUnauthorized)
-		json.NewEncoder(w).Encode(map[string]interface{}{
-			"error": map[string]interface{}{
+		json.NewEncoder(w).Encode(map[string]any{
+			"error": map[string]any{
 				"code":    "unauthorized",
 				"message": "unable to authenticate",
 			},
@@ -559,14 +559,14 @@ func TestDeleteServer_HappyPath(t *testing.T) {
 		}
 
 		w.Header().Set("Content-Type", "application/json")
-		json.NewEncoder(w).Encode(map[string]interface{}{
-			"action": map[string]interface{}{
+		json.NewEncoder(w).Encode(map[string]any{
+			"action": map[string]any{
 				"id":       1,
 				"status":   "running",
 				"command":  "delete_server",
 				"progress": 0,
-				"resources": []interface{}{
-					map[string]interface{}{"id": 42, "type": "server"},
+				"resources": []any{
+					map[string]any{"id": 42, "type": "server"},
 				},
 			},
 		})
@@ -597,8 +597,8 @@ func TestDeleteServer_NotFound(t *testing.T) {
 	srv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
 		w.Header().Set("Content-Type", "application/json")
 		w.WriteHeader(http.StatusNotFound)
-		json.NewEncoder(w).Encode(map[string]interface{}{
-			"error": map[string]interface{}{
+		json.NewEncoder(w).Encode(map[string]any{
+			"error": map[string]any{
 				"code":    "not_found",
 				"message": "server with ID '999' not found",
 			},
@@ -618,8 +618,8 @@ func TestDeleteServer_APIError(t *testing.T) {
 	srv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
 		w.Header().Set("Content-Type", "application/json")
 		w.WriteHeader(http.StatusInternalServerError)
-		json.NewEncoder(w).Encode(map[string]interface{}{
-			"error": map[string]interface{}{
+		json.NewEncoder(w).Encode(map[string]any{
+			"error": map[string]any{
 				"code":    "server_error",
 				"message": "internal server error",
 			},
diff --git a/internal/swrcache/cache.go b/internal/swrcache/cache.go
new file mode 100644
index 0000000..8ed17a1
--- /dev/null
+++ b/internal/swrcache/cache.go
@@ -0,0 +1,230 @@
+package swrcache
+
+import (
+	"context"
+	"encoding/json"
+	"os"
+	"path/filepath"
+	"strings"
+	"time"
+)
+
+const (
+	defaultFreshTTL = 5 * time.Minute
+	defaultMaxStale = time.Hour
+	refreshTimeout  = 30 * time.Second
+)
+
+// Cache provides stale-while-revalidate caching with file-backed JSON storage.
+type Cache struct {
+	dir      string
+	freshTTL time.Duration
+	maxStale time.Duration
+}
+
+// New returns a cache rooted at dir with default TTLs.
+func New(dir string) *Cache {
+	return &Cache{dir: dir, freshTTL: defaultFreshTTL, maxStale: defaultMaxStale}
+}
+
+// NewDefault returns a cache rooted at the OS user cache dir.
+func NewDefault() *Cache {
+	return New(defaultDir())
+}
+
+// WithTTLs returns a new cache rooted at dir with custom TTLs.
+func WithTTLs(dir string, freshTTL, maxStale time.Duration) *Cache {
+	return &Cache{dir: dir, freshTTL: freshTTL, maxStale: maxStale}
+}
+
+// GetOrFetch returns cached data using stale-while-revalidate semantics.
+func GetOrFetch[T any](c *Cache, ctx context.Context, key string, fetch func(context.Context) (T, error)) (T, error) {
+	if c == nil || c.dir == "" {
+		return fetch(ctx)
+	}
+
+	entry, ok, err := readEntry[T](c, key)
+	if err != nil || !ok || entry.FetchedAt.IsZero() {
+		return fetchAndStore(c, ctx, key, fetch)
+	}
+
+	age := time.Since(entry.FetchedAt)
+	if age < 0 {
+		return fetchAndStore(c, ctx, key, fetch)
+	}
+
+	if age <= c.freshTTL {
+		return entry.Data, nil
+	}
+
+	if c.maxStale <= 0 || age <= c.maxStale {
+		revalidate(c, key, fetch)
+		return entry.Data, nil
+	}
+
+	return fetchAndStore(c, ctx, key, fetch)
+}
+
+// Invalidate removes a single cached entry.
+func (c *Cache) Invalidate(key string) error {
+	if c == nil || c.dir == "" {
+		return nil
+	}
+
+	err := os.Remove(c.pathForKey(key))
+	if os.IsNotExist(err) {
+		return nil
+	}
+	return err
+}
+
+// InvalidatePrefix removes cached entries with the given key prefix.
+func (c *Cache) InvalidatePrefix(prefix string) error {
+	if c == nil || c.dir == "" {
+		return nil
+	}
+
+	entries, err := os.ReadDir(c.dir)
+	if err != nil {
+		if os.IsNotExist(err) {
+			return nil
+		}
+		return err
+	}
+
+	sanitized := sanitizeKey(prefix)
+	for _, entry := range entries {
+		name := entry.Name()
+		if strings.HasPrefix(name, sanitized) {
+			if err := os.RemoveAll(filepath.Join(c.dir, name)); err != nil {
+				return err
+			}
+		}
+	}
+
+	return nil
+}
+
+// Clear removes all cached entries in the cache directory.
+func (c *Cache) Clear() error {
+	if c == nil || c.dir == "" {
+		return nil
+	}
+
+	entries, err := os.ReadDir(c.dir)
+	if err != nil {
+		if os.IsNotExist(err) {
+			return nil
+		}
+		return err
+	}
+
+	for _, entry := range entries {
+		if err := os.RemoveAll(filepath.Join(c.dir, entry.Name())); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+func fetchAndStore[T any](c *Cache, ctx context.Context, key string, fetch func(context.Context) (T, error)) (T, error) {
+	data, err := fetch(ctx)
+	if err != nil {
+		var zero T
+		return zero, err
+	}
+	_ = writeEntry(c, key, Entry[T]{Data: data, FetchedAt: time.Now()})
+	return data, nil
+}
+
+func revalidate[T any](c *Cache, key string, fetch func(context.Context) (T, error)) {
+	go func() {
+		ctx, cancel := context.WithTimeout(context.Background(), refreshTimeout)
+		defer cancel()
+		data, err := fetch(ctx)
+		if err != nil {
+			return
+		}
+		_ = writeEntry(c, key, Entry[T]{Data: data, FetchedAt: time.Now()})
+	}()
+}
+
+func readEntry[T any](c *Cache, key string) (Entry[T], bool, error) {
+	var zero Entry[T]
+	path := c.pathForKey(key)
+	data, err := os.ReadFile(path)
+	if err != nil {
+		if os.IsNotExist(err) {
+			return zero, false, nil
+		}
+		return zero, false, err
+	}
+
+	var entry Entry[T]
+	if err := json.Unmarshal(data, &entry); err != nil {
+		return zero, false, nil
+	}
+
+	return entry, true, nil
+}
+
+func writeEntry[T any](c *Cache, key string, entry Entry[T]) error {
+	if err := os.MkdirAll(c.dir, 0o755); err != nil {
+		return err
+	}
+
+	payload, err := json.Marshal(entry)
+	if err != nil {
+		return err
+	}
+
+	tmp, err := os.CreateTemp(c.dir, sanitizeKey(key)+".tmp-*")
+	if err != nil {
+		return err
+	}
+	name := tmp.Name()
+
+	if _, err := tmp.Write(payload); err != nil {
+		tmp.Close()
+		_ = os.Remove(name)
+		return err
+	}
+	if err := tmp.Close(); err != nil {
+		_ = os.Remove(name)
+		return err
+	}
+
+	return os.Rename(name, c.pathForKey(key))
+}
+
+func (c *Cache) pathForKey(key string) string {
+	return filepath.Join(c.dir, sanitizeKey(key)+".json")
+}
+
+func defaultDir() string {
+	base, err := os.UserCacheDir()
+	if err != nil || base == "" {
+		base = os.TempDir()
+	}
+	return filepath.Join(base, "vpsm", "dns")
+}
+
+func sanitizeKey(key string) string {
+	key = strings.TrimSpace(key)
+	if key == "" {
+		return "cache"
+	}
+
+	var b strings.Builder
+	b.Grow(len(key))
+	for i := 0; i < len(key); i++ {
+		ch := key[i]
+		if (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9') || ch == '-' || ch == '_' {
+			b.WriteByte(ch)
+			continue
+		}
+		b.WriteByte('_')
+	}
+	return b.String()
+}
diff --git a/internal/swrcache/cache_test.go b/internal/swrcache/cache_test.go
new file mode 100644
index 0000000..90a5da9
--- /dev/null
+++ b/internal/swrcache/cache_test.go
@@ -0,0 +1,155 @@
+package swrcache
+
+import (
+	"context"
+	"testing"
+	"time"
+)
+
+func TestGetOrFetch_FreshCache(t *testing.T) {
+	dir := t.TempDir()
+	cache := WithTTLs(dir, 5*time.Minute, time.Hour)
+
+	key := "porkbun_domains"
+	if err := writeEntry(cache, key, Entry[string]{Data: "cached", FetchedAt: time.Now().Add(-time.Minute)}); err != nil {
+		t.Fatalf("writeEntry error: %v", err)
+	}
+
+	called := 0
+	fetch := func(ctx context.Context) (string, error) {
+		called++
+		return "fresh", nil
+	}
+
+	got, err := GetOrFetch(cache, context.Background(), key, fetch)
+	if err != nil {
+		t.Fatalf("GetOrFetch error: %v", err)
+	}
+	if got != "cached" {
+		t.Fatalf("got %q, want %q", got, "cached")
+	}
+	if called != 0 {
+		t.Fatalf("fetch called %d times, want 0", called)
+	}
+}
+
+func TestGetOrFetch_StaleCacheRevalidates(t *testing.T) {
+	dir := t.TempDir()
+	cache := WithTTLs(dir, 5*time.Minute, time.Hour)
+
+	key := "porkbun_records_example.com"
+	if err := writeEntry(cache, key, Entry[string]{Data: "cached", FetchedAt: time.Now().Add(-10 * time.Minute)}); err != nil {
+		t.Fatalf("writeEntry error: %v", err)
+	}
+
+	called := make(chan struct{}, 1)
+	fetch := func(ctx context.Context) (string, error) {
+		called <- struct{}{}
+		return "fresh", nil
+	}
+
+	got, err := GetOrFetch(cache, context.Background(), key, fetch)
+	if err != nil {
+		t.Fatalf("GetOrFetch error: %v", err)
+	}
+	if got != "cached" {
+		t.Fatalf("got %q, want %q", got, "cached")
+	}
+
+	select {
+	case <-called:
+	case <-time.After(500 * time.Millisecond):
+		t.Fatal("expected background revalidation")
+	}
+
+	deadline := time.Now().Add(750 * time.Millisecond)
+	for time.Now().Before(deadline) {
+		entry, ok, _ := readEntry[string](cache, key)
+		if ok && entry.Data == "fresh" {
+			return
+		}
+		time.Sleep(25 * time.Millisecond)
+	}
+	entry, ok, _ := readEntry[string](cache, key)
+	if !ok || entry.Data != "fresh" {
+		t.Fatalf("expected cache to be refreshed, got ok=%v data=%q", ok, entry.Data)
+	}
+}
+
+func TestGetOrFetch_ExpiredCacheFetchesSync(t *testing.T) {
+	dir := t.TempDir()
+	cache := WithTTLs(dir, 5*time.Minute, time.Hour)
+
+	key := "porkbun_domains"
+	if err := writeEntry(cache, key, Entry[string]{Data: "cached", FetchedAt: time.Now().Add(-2 * time.Hour)}); err != nil {
+		t.Fatalf("writeEntry error: %v", err)
+	}
+
+	called := 0
+	fetch := func(ctx context.Context) (string, error) {
+		called++
+		return "fresh", nil
+	}
+
+	got, err := GetOrFetch(cache, context.Background(), key, fetch)
+	if err != nil {
+		t.Fatalf("GetOrFetch error: %v", err)
+	}
+	if got != "fresh" {
+		t.Fatalf("got %q, want %q", got, "fresh")
+	}
+	if called != 1 {
+		t.Fatalf("fetch called %d times, want 1", called)
+	}
+}
+
+func TestGetOrFetch_MissFetchesSync(t *testing.T) {
+	dir := t.TempDir()
+	cache := WithTTLs(dir, 5*time.Minute, time.Hour)
+
+	called := 0
+	fetch := func(ctx context.Context) (string, error) {
+		called++
+		return "fresh", nil
+	}
+
+	got, err := GetOrFetch(cache, context.Background(), "missing", fetch)
+	if err != nil {
+		t.Fatalf("GetOrFetch error: %v", err)
+	}
+	if got != "fresh" {
+		t.Fatalf("got %q, want %q", got, "fresh")
+	}
+	if called != 1 {
+		t.Fatalf("fetch called %d times, want 1", called)
+	}
+}
+
+func TestInvalidatePrefix(t *testing.T) {
+	dir := t.TempDir()
+	cache := WithTTLs(dir, 5*time.Minute, time.Hour)
+
+	if err := writeEntry(cache, "porkbun_domains", Entry[string]{Data: "a", FetchedAt: time.Now()}); err != nil {
+		t.Fatalf("writeEntry error: %v", err)
+	}
+	if err := writeEntry(cache, "porkbun_records_example.com", Entry[string]{Data: "b", FetchedAt: time.Now()}); err != nil {
+		t.Fatalf("writeEntry error: %v", err)
+	}
+	if err := writeEntry(cache, "cloudflare_domains", Entry[string]{Data: "c", FetchedAt: time.Now()}); err != nil {
+		t.Fatalf("writeEntry error: %v", err)
+	}
+
+	if err := cache.InvalidatePrefix("porkbun_"); err != nil {
+		t.Fatalf("InvalidatePrefix error: %v", err)
+	}
+
+	if _, ok, _ := readEntry[string](cache, "porkbun_domains"); ok {
+		t.Fatal("expected porkbun_domains to be removed")
+	}
+	if _, ok, _ := readEntry[string](cache, "porkbun_records_example.com"); ok {
+		t.Fatal("expected porkbun_records_example.com to be removed")
+	}
+	if _, ok, _ := readEntry[string](cache, "cloudflare_domains"); !ok {
+		t.Fatal("expected cloudflare_domains to remain")
+	}
+}
diff --git a/internal/swrcache/entry.go b/internal/swrcache/entry.go
new file mode 100644
index 0000000..de9d76e
--- /dev/null
+++ b/internal/swrcache/entry.go
@@ -0,0 +1,9 @@
+package swrcache
+
+import "time"
+
+// Entry wraps cached data with metadata.
+type Entry[T any] struct {
+	Data      T         `json:"data"`
+	FetchedAt time.Time `json:"fetched_at"`
+}
diff --git a/internal/tui/auth_login.go b/internal/tui/auth_login.go
index 13bf3eb..e9cb648 100644
--- a/internal/tui/auth_login.go
+++ b/internal/tui/auth_login.go
@@ -142,10 +142,7 @@ func (m authLoginModel) View() string {
 
 	headerH := lipgloss.Height(header)
 	footerH := lipgloss.Height(footer)
-	contentH := m.height - headerH - footerH
-	if contentH < 1 {
-		contentH = 1
-	}
+	contentH := max(m.height-headerH-footerH, 1)
 
 	content := m.renderContent(contentH)
 
diff --git a/internal/tui/auth_status.go b/internal/tui/auth_status.go
index 03a61f5..ad725a3 100644
--- a/internal/tui/auth_status.go
+++ b/internal/tui/auth_status.go
@@ -3,6 +3,7 @@ package tui
 import (
 	"errors"
 	"fmt"
+	"strings"
 
 	"nathanbeddoewebdev/vpsm/internal/providers"
 	"nathanbeddoewebdev/vpsm/internal/services/auth"
@@ -93,10 +94,7 @@ func (m authStatusModel) View() string {
 
 	headerH := lipgloss.Height(header)
 	footerH := lipgloss.Height(footer)
-	contentH := m.height - headerH - footerH
-	if contentH < 1 {
-		contentH = 1
-	}
+	contentH := max(m.height-headerH-footerH, 1)
 
 	content := m.renderContent(contentH)
 
@@ -132,15 +130,15 @@ func (m authStatusModel) renderContent(height int) string {
 		rows = append(rows, name+statusText)
 	}
 
-	content := ""
+	var content strings.Builder
 	for i, row := range rows {
-		content += row
+		content.WriteString(row)
 		if i < len(rows)-1 {
-			content += "\n"
+			content.WriteString("\n")
 		}
 	}
 
-	card := styles.Card.Width(cardWidth).Render(content)
+	card := styles.Card.Width(cardWidth).Render(content.String())
 
 	combined := lipgloss.JoinVertical(lipgloss.Center, title, "", card)
 
diff --git a/internal/tui/components/header.go b/internal/tui/components/header.go
index 7eabcd5..45aeb7e 100644
--- a/internal/tui/components/header.go
+++ b/internal/tui/components/header.go
@@ -36,10 +36,7 @@ func Header(width int, breadcrumb string, provider string) string {
 	leftLen := lipgloss.Width(left)
 	rightLen := lipgloss.Width(right)
 	innerWidth := width - 4 // account for padding
-	gap := innerWidth - leftLen - rightLen
-	if gap < 1 {
-		gap = 1
-	}
+	gap := max(innerWidth-leftLen-rightLen, 1)
 
 	content := left + strings.Repeat(" ", gap) + right
 
diff --git a/internal/tui/components/metrics_chart.go b/internal/tui/components/metrics_chart.go
index 1cd0da8..fa7ad88 100644
--- a/internal/tui/components/metrics_chart.go
+++ b/internal/tui/components/metrics_chart.go
@@ -209,10 +209,7 @@ func MetricsChart(label string, data []float64, width int, suffix string) string
 		return styles.MutedText.Render(label + ": no data")
 	}
 
-	chartWidth := width
-	if chartWidth < 20 {
-		chartWidth = 20
-	}
+	chartWidth := max(width, 20)
 
 	lineStyle := lipgloss.NewStyle().Foreground(styles.Blue)
 	chart := newChart(chartWidth, chartHeight, data, suffix, lineStyle)
@@ -232,10 +229,7 @@ func MetricsDualChart(label string, series1, series2 []float64, legend1, legend2
 		return styles.MutedText.Render(label + ": no data")
 	}
 
-	chartWidth := width
-	if chartWidth < 20 {
-		chartWidth = 20
-	}
+	chartWidth := max(width, 20)
 
 	// Capture original emptiness before filling with zeros for chart rendering.
 	orig1Empty := len(series1) == 0
diff --git a/internal/tui/config_view.go b/internal/tui/config_view.go
index 82d687f..f8da802 100644
--- a/internal/tui/config_view.go
+++ b/internal/tui/config_view.go
@@ -179,10 +179,7 @@ func (m configViewModel) View() string {
 	headerH := lipgloss.Height(header)
 	footerH := lipgloss.Height(footer)
 	statusH := lipgloss.Height(statusBar)
-	contentH := m.height - headerH - footerH - statusH
-	if contentH < 1 {
-		contentH = 1
-	}
+	contentH := max(m.height-headerH-footerH-statusH, 1)
 
 	content := m.renderContent(contentH)
 
diff --git a/internal/tui/delete.go b/internal/tui/delete.go
index 3ba35a6..9bd393c 100644
--- a/internal/tui/delete.go
+++ b/internal/tui/delete.go
@@ -56,10 +56,7 @@ func DeleteServerForm(provider domain.Provider) (*domain.Server, error) {
 	var selectedID string
 	serverOpts := buildServerOptions(servers)
 
-	height := len(serverOpts)
-	if height < 5 {
-		height = 5
-	}
+	height := max(len(serverOpts), 5)
 	if height > 12 {
 		height = 12
 	}
diff --git a/internal/tui/dns_app.go b/internal/tui/dns_app.go
new file mode 100644
index 0000000..1d8d919
--- /dev/null
+++ b/internal/tui/dns_app.go
@@ -0,0 +1,371 @@
+package tui
+
+import (
+	"context"
+	"fmt"
+
+	"nathanbeddoewebdev/vpsm/internal/dns/domain"
+	"nathanbeddoewebdev/vpsm/internal/dns/services"
+	"nathanbeddoewebdev/vpsm/internal/tui/components"
+	"nathanbeddoewebdev/vpsm/internal/tui/styles"
+
+	"github.com/charmbracelet/bubbles/spinner"
+	tea "github.com/charmbracelet/bubbletea"
+	"github.com/charmbracelet/lipgloss"
+)
+
+// --- Navigation messages ---
+// Sent by child models to request view transitions.
+
+type dnsNavigateToDomainListMsg struct{}
+
+type dnsNavigateToRecordListMsg struct {
+	domain domain.Domain
+}
+
+type dnsNavigateToRecordShowMsg struct {
+	record domain.Record
+	domain string
+}
+
+type dnsNavigateToRecordCreateMsg struct {
+	domain string
+}
+
+type dnsNavigateToRecordEditMsg struct {
+	record domain.Record
+	domain string
+}
+
+type dnsNavigateToRecordDeleteMsg struct {
+	record domain.Record
+	domain string
+}
+
+type dnsNavigateBackMsg struct{}
+
+// --- Action messages ---
+// Sent by child models when the user confirms a destructive/creative action.
+
+type dnsCreateConfirmedMsg struct {
+	domain string
+	opts   domain.CreateRecordOpts
+}
+
+type dnsUpdateConfirmedMsg struct {
+	domain string
+	id     string
+	opts   domain.UpdateRecordOpts
+}
+
+type dnsDeleteConfirmedMsg struct {
+	domain string
+	record domain.Record
+}
+
+// --- Action result messages ---
+
+type dnsCreateResultMsg struct {
+	record *domain.Record
+	err    error
+}
+
+type dnsUpdateResultMsg struct {
+	err error
+}
+
+type dnsDeleteResultMsg struct {
+	record domain.Record
+	err    error
+}
+
+// --- Top-level App Model ---
+
+type dnsAppView int
+
+const (
+	dnsAppViewDomainList dnsAppView = iota
+	dnsAppViewRecordList
+	dnsAppViewRecordShow
+	dnsAppViewRecordCreate
+	dnsAppViewRecordEdit
+	dnsAppViewRecordDelete
+	dnsAppViewAction // spinner while API call in progress
+)
+
+type dnsAppModel struct {
+	service      *services.Service
+	providerName string
+	view         dnsAppView
+
+	// Child models
+	domainList   dnsDomainListModel
+	recordList   dnsRecordListModel
+	recordShow   dnsRecordShowModel
+	recordCreate dnsRecordCreateModel
+	recordEdit   dnsRecordEditModel
+	recordDelete dnsRecordDeleteModel
+
+	// Action state
+	actionSpinner spinner.Model
+	actionLabel   string
+	actionStatus  string
+	actionIsError bool
+
+	width  int
+	height int
+}
+
+// RunDNSApp starts the unified DNS TUI. If initialDomain is not empty,
+// it jumps straight to the record list for that domain.
+func RunDNSApp(service *services.Service, providerName string, initialDomain string) (tea.Model, error) {
+	s := spinner.New()
+	s.Spinner = spinner.Dot
+	s.Style = lipgloss.NewStyle().Foreground(styles.Blue)
+
+	m := dnsAppModel{
+		service:       service,
+		providerName:  providerName,
+		view:          dnsAppViewDomainList,
+		actionSpinner: s,
+	}
+
+	if initialDomain != "" {
+		m.switchToRecordList(initialDomain)
+	} else {
+		m.switchToDomainList()
+	}
+
+	p := tea.NewProgram(m, tea.WithAltScreen())
+	return p.Run()
+}
+
+func (m *dnsAppModel) switchToDomainList() {
+	m.view = dnsAppViewDomainList
+	m.domainList = newDNSDomainListModel(m.service, m.providerName, true, m.width, m.height)
+}
+
+func (m *dnsAppModel) switchToRecordList(domain string) {
+	m.view = dnsAppViewRecordList
+	m.recordList = newDNSRecordListModel(m.service, m.providerName, domain, true, m.width, m.height)
+}
+
+func (m *dnsAppModel) switchToRecordShow(rec domain.Record, domainName string) {
+	m.view = dnsAppViewRecordShow
+	m.recordShow = newDNSRecordShowModel(rec, domainName, m.providerName, true, m.width, m.height)
+}
+
+func (m dnsAppModel) Init() tea.Cmd {
+	return m.domainList.Init()
+}
+
+func (m dnsAppModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
+	var cmds []tea.Cmd
+
+	switch msg := msg.(type) {
+	case tea.KeyMsg:
+		if msg.String() == "ctrl+c" {
+			return m, tea.Quit
+		}
+
+	case tea.WindowSizeMsg:
+		m.width = msg.Width
+		m.height = msg.Height
+		return m.updateChild(msg)
+
+	case spinner.TickMsg:
+		var cmd tea.Cmd
+		if m.view == dnsAppViewAction {
+			m.actionSpinner, cmd = m.actionSpinner.Update(msg)
+			cmds = append(cmds, cmd)
+		}
+		// Also forward to child so loading spinners animate
+		childModel, childCmd := m.updateChild(msg)
+		m = childModel.(dnsAppModel)
+		cmds = append(cmds, childCmd)
+		return m, tea.Batch(cmds...)
+
+	case dnsNavigateToDomainListMsg:
+		m.switchToDomainList()
+		return m, m.domainList.Init()
+
+	case dnsNavigateToRecordListMsg:
+		m.switchToRecordList(msg.domain.Name)
+		return m, m.recordList.Init()
+
+	case dnsNavigateToRecordShowMsg:
+		m.switchToRecordShow(msg.record, msg.domain)
+		return m, m.recordShow.Init()
+
+	case dnsNavigateToRecordCreateMsg:
+		m.view = dnsAppViewRecordCreate
+		m.recordCreate = newDNSRecordCreateModel(m.service, m.providerName, msg.domain, domain.CreateRecordOpts{}, true, m.width, m.height)
+		return m, m.recordCreate.Init()
+
+	case dnsNavigateToRecordEditMsg:
+		m.view = dnsAppViewRecordEdit
+		m.recordEdit = newDNSRecordEditModel(m.service, m.providerName, msg.domain, msg.record, true, m.width, m.height)
+		return m, m.recordEdit.Init()
+
+	case dnsNavigateToRecordDeleteMsg:
+		m.view = dnsAppViewRecordDelete
+		m.recordDelete = newDNSRecordDeleteModel(m.service, m.providerName, msg.domain, msg.record, true, m.width, m.height)
+		return m, m.recordDelete.Init()
+
+	// Actions
+	case dnsCreateConfirmedMsg:
+		m.view = dnsAppViewAction
+		m.actionLabel = fmt.Sprintf("Creating record for %s", msg.domain)
+		m.actionIsError = false
+		m.actionStatus = ""
+		return m, tea.Batch(m.actionSpinner.Tick, func() tea.Msg {
+			rec, err := m.service.CreateRecord(context.Background(), msg.domain, msg.opts)
+			return dnsCreateResultMsg{record: rec, err: err}
+		})
+
+	case dnsUpdateConfirmedMsg:
+		m.view = dnsAppViewAction
+		m.actionLabel = fmt.Sprintf("Updating record %s", msg.id)
+		m.actionIsError = false
+		m.actionStatus = ""
+		return m, tea.Batch(m.actionSpinner.Tick, func() tea.Msg {
+			err := m.service.UpdateRecord(context.Background(), msg.domain, msg.id, msg.opts)
+			return dnsUpdateResultMsg{err: err}
+		})
+
+	case dnsDeleteConfirmedMsg:
+		m.view = dnsAppViewAction
+		m.actionLabel = fmt.Sprintf("Deleting record %s", msg.record.ID)
+		m.actionIsError = false
+		m.actionStatus = ""
+		return m, tea.Batch(m.actionSpinner.Tick, func() tea.Msg {
+			err := m.service.DeleteRecord(context.Background(), msg.domain, msg.record.ID)
+			return dnsDeleteResultMsg{record: msg.record, err: err}
+		})
+
+	// Results
+	case dnsCreateResultMsg:
+		if msg.err != nil {
+			m.actionIsError = true
+			m.actionStatus = msg.err.Error()
+			return m, nil
+		}
+		// Go back to record list and refresh
+		m.view = dnsAppViewRecordList
+		m.recordList.persistentStatus = fmt.Sprintf("Created record %s", msg.record.ID)
+		m.recordList.statusIsError = false
+		m.recordList.loading = true
+		return m, m.recordList.loadRecordsCmd()
+
+	case dnsUpdateResultMsg:
+		if msg.err != nil {
+			m.actionIsError = true
+			m.actionStatus = msg.err.Error()
+			return m, nil
+		}
+		m.view = dnsAppViewRecordList
+		m.recordList.persistentStatus = "Record updated successfully"
+		m.recordList.statusIsError = false
+		m.recordList.loading = true
+		return m, m.recordList.loadRecordsCmd()
+
+	case dnsDeleteResultMsg:
+		if msg.err != nil {
+			m.actionIsError = true
+			m.actionStatus = msg.err.Error()
+			return m, nil
+		}
+		m.view = dnsAppViewRecordList
+		m.recordList.persistentStatus = fmt.Sprintf("Deleted record %s", msg.record.ID)
+		m.recordList.statusIsError = false
+		m.recordList.loading = true
+		return m, m.recordList.loadRecordsCmd()
+
+	case dnsNavigateBackMsg:
+		if m.view == dnsAppViewRecordShow || m.view == dnsAppViewRecordCreate || m.view == dnsAppViewRecordEdit || m.view == dnsAppViewRecordDelete {
+			m.view = dnsAppViewRecordList
+			return m, nil
+		}
+		if m.view == dnsAppViewRecordList {
+			// Only go back to domain list if we have it (i.e. not launched directly into record list)
+			if m.domainList.service != nil {
+				m.view = dnsAppViewDomainList
+				return m, nil
+			} else {
+				return m, tea.Quit
+			}
+		}
+	}
+
+	childModel, cmd := m.updateChild(msg)
+	m = childModel.(dnsAppModel)
+	cmds = append(cmds, cmd)
+
+	return m, tea.Batch(cmds...)
+}
+
+func (m dnsAppModel) updateChild(msg tea.Msg) (tea.Model, tea.Cmd) {
+	var cmd tea.Cmd
+	switch m.view {
+	case dnsAppViewDomainList:
+		var updated tea.Model
+		updated, cmd = m.domainList.Update(msg)
+		m.domainList = updated.(dnsDomainListModel)
+	case dnsAppViewRecordList:
+		var updated tea.Model
+		updated, cmd = m.recordList.Update(msg)
+		m.recordList = updated.(dnsRecordListModel)
+	case dnsAppViewRecordShow:
+		var updated tea.Model
+		updated, cmd = m.recordShow.Update(msg)
+		m.recordShow = updated.(dnsRecordShowModel)
+	case dnsAppViewRecordCreate:
+		var updated tea.Model
+		updated, cmd = m.recordCreate.Update(msg)
+		m.recordCreate = updated.(dnsRecordCreateModel)
+	case dnsAppViewRecordEdit:
+		var updated tea.Model
+		updated, cmd = m.recordEdit.Update(msg)
+		m.recordEdit = updated.(dnsRecordEditModel)
+	case dnsAppViewRecordDelete:
+		var updated tea.Model
+		updated, cmd = m.recordDelete.Update(msg)
+		m.recordDelete = updated.(dnsRecordDeleteModel)
+	}
+	return m, cmd
+}
+
+func (m dnsAppModel) View() string {
+	var view string
+
+	switch m.view {
+	case dnsAppViewDomainList:
+		view = m.domainList.View()
+	case dnsAppViewRecordList:
+		view = m.recordList.View()
+	case dnsAppViewRecordShow:
+		view = m.recordShow.View()
+	case dnsAppViewRecordCreate:
+		view = m.recordCreate.View()
+	case dnsAppViewRecordEdit:
+		view = m.recordEdit.View()
+	case dnsAppViewRecordDelete:
+		view = m.recordDelete.View()
+	case dnsAppViewAction:
+		header := components.Header(m.width, "dns > processing", m.providerName)
+		content := fmt.Sprintf("\n  %s %s\n", m.actionSpinner.View(), m.actionLabel)
+
+		statusStyle := styles.Value
+		if m.actionIsError {
+			statusStyle = styles.ErrorText
+		}
+
+		if m.actionStatus != "" {
+			content += fmt.Sprintf("\n  %s\n", statusStyle.Render(m.actionStatus))
+		}
+
+		view = lipgloss.JoinVertical(lipgloss.Left, header, content)
+	}
+
+	return view
+}
diff --git a/internal/tui/dns_domain_list.go b/internal/tui/dns_domain_list.go
new file mode 100644
index 0000000..03b345d
--- /dev/null
+++ b/internal/tui/dns_domain_list.go
@@ -0,0 +1,239 @@
+package tui
+
+import (
+	"context"
+	"fmt"
+
+	"nathanbeddoewebdev/vpsm/internal/dns/domain"
+	"nathanbeddoewebdev/vpsm/internal/dns/services"
+	"nathanbeddoewebdev/vpsm/internal/tui/components"
+	"nathanbeddoewebdev/vpsm/internal/tui/styles"
+
+	"github.com/charmbracelet/bubbles/spinner"
+	tea "github.com/charmbracelet/bubbletea"
+	"github.com/charmbracelet/lipgloss"
+)
+
+// --- Messages ---
+
+type dnsDomainsLoadedMsg struct {
+	domains []domain.Domain
+}
+
+type dnsDomainsErrorMsg struct {
+	err error
+}
+
+// --- Domain list model ---
+
+type dnsDomainListModel struct {
+	service      *services.Service
+	providerName string
+
+	domains []domain.Domain
+	cursor  int
+
+	width  int
+	height int
+
+	loading       bool
+	spinner       spinner.Model
+	err           error
+	status        string
+	statusIsError bool
+
+	embedded bool
+}
+
+func newDNSDomainListModel(svc *services.Service, providerName string, embedded bool, width, height int) dnsDomainListModel {
+	s := spinner.New()
+	s.Spinner = spinner.Dot
+	s.Style = lipgloss.NewStyle().Foreground(styles.Blue)
+
+	return dnsDomainListModel{
+		service:      svc,
+		providerName: providerName,
+		embedded:     embedded,
+		width:        width,
+		height:       height,
+		loading:      true,
+		spinner:      s,
+	}
+}
+
+func (m dnsDomainListModel) Init() tea.Cmd {
+	return tea.Batch(m.spinner.Tick, m.loadDomainsCmd())
+}
+
+func (m dnsDomainListModel) loadDomainsCmd() tea.Cmd {
+	return func() tea.Msg {
+		domains, err := m.service.ListDomains(context.Background())
+		if err != nil {
+			return dnsDomainsErrorMsg{err}
+		}
+		return dnsDomainsLoadedMsg{domains}
+	}
+}
+
+func (m dnsDomainListModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
+	var cmds []tea.Cmd
+
+	switch msg := msg.(type) {
+	case tea.WindowSizeMsg:
+		m.width = msg.Width
+		m.height = msg.Height
+
+	case tea.KeyMsg:
+		switch msg.String() {
+		case "q":
+			if !m.embedded {
+				return m, tea.Quit
+			}
+		case "up", "k":
+			if m.cursor > 0 {
+				m.cursor--
+			}
+		case "down", "j":
+			if m.cursor < len(m.domains)-1 {
+				m.cursor++
+			}
+		case "r":
+			m.loading = true
+			m.err = nil
+			return m, m.loadDomainsCmd()
+		case "enter":
+			if len(m.domains) > 0 {
+				dom := m.domains[m.cursor]
+				if m.embedded {
+					return m, func() tea.Msg { return dnsNavigateToRecordListMsg{domain: dom} }
+				}
+				return m, tea.Quit
+			}
+		}
+
+	case dnsDomainsLoadedMsg:
+		m.loading = false
+		m.domains = msg.domains
+		m.cursor = 0
+		if len(m.domains) == 0 {
+			m.status = "No domains found."
+		} else {
+			m.status = fmt.Sprintf("Loaded %d domains.", len(m.domains))
+		}
+
+	case dnsDomainsErrorMsg:
+		m.loading = false
+		m.err = msg.err
+		m.status = msg.err.Error()
+		m.statusIsError = true
+
+	case spinner.TickMsg:
+		if m.loading {
+			var cmd tea.Cmd
+			m.spinner, cmd = m.spinner.Update(msg)
+			cmds = append(cmds, cmd)
+		}
+	}
+
+	return m, tea.Batch(cmds...)
+}
+
+func (m dnsDomainListModel) View() string {
+	header := components.Header(m.width, "dns > domains", m.providerName)
+
+	bindings := []components.KeyBinding{
+		{Key: "j/k", Desc: "navigate"},
+		{Key: "enter", Desc: "records"},
+		{Key: "r", Desc: "refresh"},
+	}
+	if !m.embedded {
+		bindings = append(bindings, components.KeyBinding{Key: "q", Desc: "quit"})
+	}
+	footer := components.Footer(m.width, bindings)
+
+	statusBar := components.StatusBar(m.width, m.status, m.statusIsError)
+
+	headerH := lipgloss.Height(header)
+	footerH := lipgloss.Height(footer)
+	statusH := lipgloss.Height(statusBar)
+	contentH := m.height - headerH - footerH - statusH
+	if contentH < 1 {
+		contentH = 1
+	}
+
+	var content string
+	if m.loading {
+		content = fmt.Sprintf("\n  %s Loading domains...", m.spinner.View())
+	} else if m.err != nil {
+		content = fmt.Sprintf("\n  %s", styles.ErrorText.Render(m.err.Error()))
+	} else if len(m.domains) == 0 {
+		content = "\n  No domains found in this account."
+	} else {
+		content = m.renderTable(contentH)
+	}
+
+	// Pad content to fill height
+	lines := lipgloss.Height(content)
+	if lines < contentH {
+		content += lipgloss.NewStyle().Height(contentH - lines).Render("")
+	}
+
+	return lipgloss.JoinVertical(lipgloss.Left, header, content, statusBar, footer)
+}
+
+func (m dnsDomainListModel) renderTable(height int) string {
+	if len(m.domains) == 0 {
+		return ""
+	}
+
+	cols := []int{30, 15, 10, 20}
+
+	header := styles.TableHeader.Render(
+		fmt.Sprintf("  %-*s %-*s %-*s %-*s",
+			cols[0], "DOMAIN",
+			cols[1], "STATUS",
+			cols[2], "TLD",
+			cols[3], "EXPIRES",
+		),
+	)
+
+	var rows []string
+	rows = append(rows, header)
+
+	// Simple pagination/viewport calculation
+	start := 0
+	if m.cursor >= height-2 {
+		start = m.cursor - (height - 3)
+	}
+	end := start + height - 2
+	if end > len(m.domains) {
+		end = len(m.domains)
+	}
+
+	for i := start; i < end; i++ {
+		d := m.domains[i]
+
+		cursor := " "
+		rowStyle := styles.TableCell
+		if i == m.cursor {
+			cursor = styles.AccentText.Render(">")
+			rowStyle = styles.TableSelectedRow
+		}
+
+		status := d.Status
+		if status == "ACTIVE" {
+			status = styles.SuccessText.Render(status)
+		}
+
+		row := fmt.Sprintf("%s %-*s %-*s %-*s %-*s",
+			cursor,
+			cols[0], d.Name,
+			cols[1], status,
+			cols[2], d.TLD,
+			cols[3], d.ExpireDate,
+		)
+		rows = append(rows, rowStyle.Render(row))
+	}
+
+	return lipgloss.JoinVertical(lipgloss.Left, rows...)
+}
diff --git a/internal/tui/dns_record_create.go b/internal/tui/dns_record_create.go
new file mode 100644
index 0000000..9cd312f
--- /dev/null
+++ b/internal/tui/dns_record_create.go
@@ -0,0 +1,437 @@
+package tui
+
+import (
+	"fmt"
+	"strconv"
+	"strings"
+
+	"nathanbeddoewebdev/vpsm/internal/dns/domain"
+	"nathanbeddoewebdev/vpsm/internal/dns/services"
+	"nathanbeddoewebdev/vpsm/internal/tui/components"
+	"nathanbeddoewebdev/vpsm/internal/tui/styles"
+
+	"github.com/charmbracelet/bubbles/textinput"
+	tea "github.com/charmbracelet/bubbletea"
+	"github.com/charmbracelet/lipgloss"
+)
+
+type dnsCreateStep int
+
+const (
+	dnsCreateStepType dnsCreateStep = iota
+	dnsCreateStepName
+	dnsCreateStepContent
+	dnsCreateStepTTL
+	dnsCreateStepPriority
+	dnsCreateStepNotes
+	dnsCreateStepConfirm
+)
+
+type dnsRecordCreateModel struct {
+	service      *services.Service
+	providerName string
+	domain       string
+	opts         domain.CreateRecordOpts
+
+	step dnsCreateStep
+
+	// Type selection
+	types  []domain.RecordType
+	cursor int
+
+	// Text inputs
+	inputs map[dnsCreateStep]textinput.Model
+
+	embedded bool
+	width    int
+	height   int
+}
+
+func newDNSRecordCreateModel(svc *services.Service, providerName, domainName string, prefill domain.CreateRecordOpts, embedded bool, width, height int) dnsRecordCreateModel {
+	types := []domain.RecordType{"A", "AAAA", "CNAME", "MX", "TXT", "NS", "SRV", "CAA", "ALIAS"}
+
+	inputs := make(map[dnsCreateStep]textinput.Model)
+
+	// Name input
+	nameIn := textinput.New()
+	nameIn.Placeholder = "e.g. www (leave empty for root)"
+	nameIn.SetValue(prefill.Name)
+	inputs[dnsCreateStepName] = nameIn
+
+	// Content input
+	contentIn := textinput.New()
+	contentIn.Placeholder = "e.g. 1.2.3.4"
+	contentIn.SetValue(prefill.Content)
+	inputs[dnsCreateStepContent] = contentIn
+
+	// TTL input
+	ttlIn := textinput.New()
+	ttlIn.Placeholder = "e.g. 600"
+	if prefill.TTL > 0 {
+		ttlIn.SetValue(strconv.Itoa(prefill.TTL))
+	}
+	inputs[dnsCreateStepTTL] = ttlIn
+
+	// Priority input
+	prioIn := textinput.New()
+	prioIn.Placeholder = "e.g. 10"
+	if prefill.Priority > 0 {
+		prioIn.SetValue(strconv.Itoa(prefill.Priority))
+	}
+	inputs[dnsCreateStepPriority] = prioIn
+
+	// Notes input
+	notesIn := textinput.New()
+	notesIn.Placeholder = "Optional notes"
+	notesIn.SetValue(prefill.Notes)
+	inputs[dnsCreateStepNotes] = notesIn
+
+	// Preset the opts type
+	opts := prefill
+	if opts.Type == "" {
+		opts.Type = "A" // default
+	}
+
+	cursor := 0
+	for i, t := range types {
+		if t == opts.Type {
+			cursor = i
+			break
+		}
+	}
+
+	return dnsRecordCreateModel{
+		service:      svc,
+		providerName: providerName,
+		domain:       domainName,
+		opts:         opts,
+		step:         dnsCreateStepType,
+		types:        types,
+		cursor:       cursor,
+		inputs:       inputs,
+		embedded:     embedded,
+		width:        width,
+		height:       height,
+	}
+}
+
+func (m dnsRecordCreateModel) Init() tea.Cmd {
+	return nil
+}
+
+func (m dnsRecordCreateModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
+	var cmds []tea.Cmd
+
+	switch msg := msg.(type) {
+	case tea.WindowSizeMsg:
+		m.width = msg.Width
+		m.height = msg.Height
+
+	case tea.KeyMsg:
+		switch msg.String() {
+		case "esc":
+			if m.step > dnsCreateStepType {
+				m.step--
+				// Skip priority if not MX or SRV
+				if m.step == dnsCreateStepPriority && m.opts.Type != "MX" && m.opts.Type != "SRV" {
+					m.step--
+				}
+				m.focusInput()
+				return m, nil
+			}
+			if m.embedded {
+				return m, func() tea.Msg { return dnsNavigateBackMsg{} }
+			}
+			return m, tea.Quit
+		case "ctrl+c":
+			return m, tea.Quit
+		case "up", "k":
+			if m.step == dnsCreateStepType && m.cursor > 0 {
+				m.cursor--
+			}
+		case "down", "j":
+			if m.step == dnsCreateStepType && m.cursor < len(m.types)-1 {
+				m.cursor++
+			}
+		case "enter":
+			// Process current step
+			switch m.step {
+			case dnsCreateStepType:
+				m.opts.Type = m.types[m.cursor]
+				m.updatePlaceholders()
+				m.step++
+				m.focusInput()
+			case dnsCreateStepName:
+				m.opts.Name = m.inputs[m.step].Value()
+				m.step++
+				m.focusInput()
+			case dnsCreateStepContent:
+				val := m.inputs[m.step].Value()
+				if val == "" {
+					return m, nil // Don't allow empty content
+				}
+				m.opts.Content = val
+				m.step++
+				m.focusInput()
+			case dnsCreateStepTTL:
+				val := m.inputs[m.step].Value()
+				if val != "" {
+					if ttl, err := strconv.Atoi(val); err == nil {
+						m.opts.TTL = ttl
+					}
+				}
+				m.step++
+				if m.opts.Type != "MX" && m.opts.Type != "SRV" {
+					m.step++ // skip priority
+				}
+				m.focusInput()
+			case dnsCreateStepPriority:
+				val := m.inputs[m.step].Value()
+				if val != "" {
+					if prio, err := strconv.Atoi(val); err == nil {
+						m.opts.Priority = prio
+					}
+				}
+				m.step++
+				m.focusInput()
+			case dnsCreateStepNotes:
+				m.opts.Notes = m.inputs[m.step].Value()
+				m.step++ // Go to confirm
+			case dnsCreateStepConfirm:
+				if m.embedded {
+					return m, func() tea.Msg {
+						return dnsCreateConfirmedMsg{domain: m.domain, opts: m.opts}
+					}
+				}
+				return m, tea.Quit
+			}
+		}
+
+	}
+
+	// Route msg to current input if applicable
+	if m.step >= dnsCreateStepName && m.step <= dnsCreateStepNotes {
+		if in, ok := m.inputs[m.step]; ok {
+			var cmd tea.Cmd
+			in, cmd = in.Update(msg)
+			m.inputs[m.step] = in
+			cmds = append(cmds, cmd)
+		}
+	}
+
+	return m, tea.Batch(cmds...)
+}
+
+func (m *dnsRecordCreateModel) focusInput() {
+	for k, in := range m.inputs {
+		if k == m.step {
+			in.Focus()
+		} else {
+			in.Blur()
+		}
+		m.inputs[k] = in
+	}
+}
+
+func (m *dnsRecordCreateModel) updatePlaceholders() {
+	in := m.inputs[dnsCreateStepContent]
+	switch m.opts.Type {
+	case "A":
+		in.Placeholder = "e.g. 1.2.3.4"
+	case "AAAA":
+		in.Placeholder = "e.g. 2001:db8::1"
+	case "CNAME":
+		in.Placeholder = "e.g. example.com"
+	case "MX":
+		in.Placeholder = "e.g. mail.example.com"
+	case "TXT":
+		in.Placeholder = `e.g. "v=spf1 include:_spf.example.com ~all"`
+	default:
+		in.Placeholder = "Record content"
+	}
+	m.inputs[dnsCreateStepContent] = in
+}
+
+func (m dnsRecordCreateModel) View() string {
+	header := components.Header(m.width, "dns > create", m.providerName)
+
+	bindings := []components.KeyBinding{
+		{Key: "esc", Desc: "back"},
+	}
+	if m.step == dnsCreateStepType {
+		bindings = append(bindings, components.KeyBinding{Key: "j/k", Desc: "select"})
+		bindings = append(bindings, components.KeyBinding{Key: "enter", Desc: "next"})
+	} else if m.step == dnsCreateStepConfirm {
+		bindings = append(bindings, components.KeyBinding{Key: "enter", Desc: "confirm"})
+	} else {
+		bindings = append(bindings, components.KeyBinding{Key: "enter", Desc: "next"})
+	}
+
+	footer := components.Footer(m.width, bindings)
+
+	headerH := lipgloss.Height(header)
+	footerH := lipgloss.Height(footer)
+	contentH := m.height - headerH - footerH
+	if contentH < 1 {
+		contentH = 1
+	}
+
+	var content string
+	switch m.step {
+	case dnsCreateStepType:
+		content = m.renderTypeStep()
+	case dnsCreateStepName:
+		content = m.renderInputStep("Subdomain Name")
+	case dnsCreateStepContent:
+		content = m.renderInputStep(fmt.Sprintf("%s Content", m.opts.Type))
+	case dnsCreateStepTTL:
+		content = m.renderInputStep("TTL (seconds)")
+	case dnsCreateStepPriority:
+		content = m.renderInputStep("Priority")
+	case dnsCreateStepNotes:
+		content = m.renderInputStep("Notes")
+	case dnsCreateStepConfirm:
+		content = m.renderConfirmStep()
+	}
+
+	content = m.renderStepper() + "\n\n" + content
+
+	// Pad to height
+	lines := lipgloss.Height(content)
+	if lines < contentH {
+		content += strings.Repeat("\n", contentH-lines)
+	}
+
+	return lipgloss.JoinVertical(lipgloss.Left, header, content, footer)
+}
+
+func (m dnsRecordCreateModel) renderStepper() string {
+	steps := []string{"Type", "Name", "Content", "TTL"}
+	if m.opts.Type == "MX" || m.opts.Type == "SRV" {
+		steps = append(steps, "Priority")
+	}
+	steps = append(steps, "Confirm")
+
+	// Calculate which logical step we are on (accounting for skipped priority)
+	logicalStep := int(m.step)
+	if m.step >= dnsCreateStepPriority && m.opts.Type != "MX" && m.opts.Type != "SRV" {
+		logicalStep--
+	}
+	if m.step >= dnsCreateStepNotes {
+		// Notes doesn't get a dot
+		logicalStep--
+	}
+
+	var parts []string
+	for i, step := range steps {
+		if i == logicalStep {
+			parts = append(parts, styles.AccentText.Render(" "+step))
+		} else if i < logicalStep {
+			parts = append(parts, styles.SuccessText.Render(" ")+styles.MutedText.Render(step))
+		} else {
+			parts = append(parts, styles.MutedText.Render(" "+step))
+		}
+	}
+	return "  " + strings.Join(parts, "  ")
+}
+
+func (m dnsRecordCreateModel) renderTypeStep() string {
+	var rows []string
+	rows = append(rows, "  "+styles.Subtitle.Render("Select record type:"))
+	rows = append(rows, "")
+
+	for i, t := range m.types {
+		cursor := " "
+		style := styles.Value
+		if i == m.cursor {
+			cursor = styles.AccentText.Render(">")
+			style = styles.AccentText
+		}
+
+		desc := ""
+		switch t {
+		case "A":
+			desc = "IPv4 address"
+		case "AAAA":
+			desc = "IPv6 address"
+		case "CNAME":
+			desc = "Canonical name"
+		case "MX":
+			desc = "Mail exchange"
+		case "TXT":
+			desc = "Text record"
+		case "NS":
+			desc = "Name server"
+		case "SRV":
+			desc = "Service locator"
+		case "CAA":
+			desc = "Certificate authority"
+		case "ALIAS":
+			desc = "CNAME flattening"
+		}
+
+		row := fmt.Sprintf("  %s %-8s %s", cursor, style.Render(string(t)), styles.MutedText.Render(desc))
+		rows = append(rows, row)
+	}
+
+	return strings.Join(rows, "\n")
+}
+
+func (m dnsRecordCreateModel) renderInputStep(title string) string {
+	in := m.inputs[m.step]
+
+	// Apply proper styling to the input
+	in.PromptStyle = styles.AccentText
+	in.TextStyle = styles.Value
+	in.PlaceholderStyle = styles.MutedText
+
+	if in.Focused() {
+		// Draw a border around it
+		view := in.View()
+		box := styles.CardActive.Render(view)
+		return fmt.Sprintf("  %s\n\n%s", styles.Subtitle.Render(title+":"), "  "+box)
+	}
+	return fmt.Sprintf("  %s\n\n  %s", styles.Subtitle.Render(title+":"), in.View())
+}
+
+func (m dnsRecordCreateModel) renderConfirmStep() string {
+	title := styles.Title.Render("Create DNS Record")
+
+	o := m.opts
+	ttlStr := strconv.Itoa(o.TTL)
+	if o.TTL == 0 {
+		ttlStr = "Default"
+	}
+
+	name := o.Name
+	if name == "" {
+		name = "(Root)"
+	}
+
+	fields := []string{
+		lipgloss.JoinHorizontal(lipgloss.Left, lipgloss.NewStyle().Width(10).Render(styles.Label.Render("Domain")), styles.Value.Render(m.domain)),
+		lipgloss.JoinHorizontal(lipgloss.Left, lipgloss.NewStyle().Width(10).Render(styles.Label.Render("Type")), styles.Value.Render(string(o.Type))),
+		lipgloss.JoinHorizontal(lipgloss.Left, lipgloss.NewStyle().Width(10).Render(styles.Label.Render("Name")), styles.Value.Render(name)),
+		lipgloss.JoinHorizontal(lipgloss.Left, lipgloss.NewStyle().Width(10).Render(styles.Label.Render("Content")), styles.Value.Render(o.Content)),
+		lipgloss.JoinHorizontal(lipgloss.Left, lipgloss.NewStyle().Width(10).Render(styles.Label.Render("TTL")), styles.Value.Render(ttlStr)),
+	}
+
+	if o.Priority > 0 {
+		fields = append(fields, lipgloss.JoinHorizontal(lipgloss.Left, lipgloss.NewStyle().Width(10).Render(styles.Label.Render("Priority")), styles.Value.Render(strconv.Itoa(o.Priority))))
+	}
+	if o.Notes != "" {
+		fields = append(fields, lipgloss.JoinHorizontal(lipgloss.Left, lipgloss.NewStyle().Width(10).Render(styles.Label.Render("Notes")), styles.Value.Render(o.Notes)))
+	}
+
+	cardContent := lipgloss.JoinVertical(lipgloss.Left,
+		title,
+		"",
+		strings.Join(fields, "\n"),
+	)
+
+	return lipgloss.JoinVertical(lipgloss.Center,
+		styles.CardActive.Render(cardContent),
+		"",
+		"  Press Enter to Create",
+	)
+}
diff --git a/internal/tui/dns_record_delete.go b/internal/tui/dns_record_delete.go
new file mode 100644
index 0000000..1dc12a3
--- /dev/null
+++ b/internal/tui/dns_record_delete.go
@@ -0,0 +1,196 @@
+package tui
+
+import (
+	"context"
+	"fmt"
+	"strings"
+
+	"nathanbeddoewebdev/vpsm/internal/dns/domain"
+	"nathanbeddoewebdev/vpsm/internal/dns/services"
+	"nathanbeddoewebdev/vpsm/internal/tui/components"
+	"nathanbeddoewebdev/vpsm/internal/tui/styles"
+
+	"github.com/charmbracelet/bubbles/spinner"
+	tea "github.com/charmbracelet/bubbletea"
+	"github.com/charmbracelet/lipgloss"
+)
+
+type dnsRecordDeleteModel struct {
+	service      *services.Service
+	providerName string
+	domain       string
+	record       domain.Record
+
+	confirmIdx int // 0 = Delete, 1 = Cancel
+	confirmed  bool
+	loading    bool
+	spinner    spinner.Model
+	err        error
+
+	embedded bool
+	width    int
+	height   int
+}
+
+func newDNSRecordDeleteModel(svc *services.Service, providerName, domainName string, rec domain.Record, embedded bool, width, height int) dnsRecordDeleteModel {
+	s := spinner.New()
+	s.Spinner = spinner.Dot
+	s.Style = lipgloss.NewStyle().Foreground(styles.Red)
+
+	return dnsRecordDeleteModel{
+		service:      svc,
+		providerName: providerName,
+		domain:       domainName,
+		record:       rec,
+		confirmIdx:   1, // Default to Cancel for safety
+		embedded:     embedded,
+		width:        width,
+		height:       height,
+		spinner:      s,
+	}
+}
+
+func (m dnsRecordDeleteModel) Init() tea.Cmd {
+	return nil
+}
+
+func (m dnsRecordDeleteModel) deleteCmd() tea.Cmd {
+	return func() tea.Msg {
+		err := m.service.DeleteRecord(context.Background(), m.domain, m.record.ID)
+		return dnsDeleteResultMsg{record: m.record, err: err}
+	}
+}
+
+func (m dnsRecordDeleteModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
+	var cmds []tea.Cmd
+
+	switch msg := msg.(type) {
+	case tea.WindowSizeMsg:
+		m.width = msg.Width
+		m.height = msg.Height
+
+	case tea.KeyMsg:
+		if m.loading {
+			break
+		}
+		switch msg.String() {
+		case "esc", "q":
+			if m.embedded {
+				return m, func() tea.Msg { return dnsNavigateBackMsg{} }
+			}
+			return m, tea.Quit
+		case "left", "h":
+			if m.confirmIdx > 0 {
+				m.confirmIdx--
+			}
+		case "right", "l":
+			if m.confirmIdx < 1 {
+				m.confirmIdx++
+			}
+		case "enter":
+			if m.confirmIdx == 1 {
+				// Cancel
+				if m.embedded {
+					return m, func() tea.Msg { return dnsNavigateBackMsg{} }
+				}
+				return m, tea.Quit
+			}
+			// Delete
+			m.confirmed = true
+			if m.embedded {
+				return m, func() tea.Msg { return dnsDeleteConfirmedMsg{domain: m.domain, record: m.record} }
+			}
+			m.loading = true
+			return m, tea.Batch(m.spinner.Tick, m.deleteCmd())
+		}
+
+	case dnsDeleteResultMsg:
+		m.loading = false
+		m.err = msg.err
+		if m.err == nil && !m.embedded {
+			return m, tea.Quit
+		}
+
+	case spinner.TickMsg:
+		if m.loading {
+			var cmd tea.Cmd
+			m.spinner, cmd = m.spinner.Update(msg)
+			cmds = append(cmds, cmd)
+		}
+	}
+
+	return m, tea.Batch(cmds...)
+}
+
+func (m dnsRecordDeleteModel) View() string {
+	header := components.Header(m.width, "dns > delete", m.providerName)
+
+	bindings := []components.KeyBinding{
+		{Key: "/", Desc: "select"},
+		{Key: "enter", Desc: "confirm"},
+		{Key: "esc", Desc: "cancel"},
+	}
+	footer := components.Footer(m.width, bindings)
+
+	headerH := lipgloss.Height(header)
+	footerH := lipgloss.Height(footer)
+	contentH := m.height - headerH - footerH
+	if contentH < 1 {
+		contentH = 1
+	}
+
+	var content string
+	if m.loading {
+		content = fmt.Sprintf("\n  %s Deleting record...", m.spinner.View())
+	} else if m.err != nil {
+		content = fmt.Sprintf("\n  %s", styles.ErrorText.Render(m.err.Error()))
+	} else {
+		content = m.renderCard()
+	}
+
+	content = lipgloss.Place(m.width, contentH, lipgloss.Center, lipgloss.Center, content)
+
+	return lipgloss.JoinVertical(lipgloss.Left, header, content, footer)
+}
+
+func (m dnsRecordDeleteModel) renderCard() string {
+	title := lipgloss.NewStyle().Foreground(styles.Red).Bold(true).Render("Delete DNS Record")
+
+	r := m.record
+
+	fields := []string{
+		lipgloss.JoinHorizontal(lipgloss.Left, lipgloss.NewStyle().Width(10).Render(styles.Label.Render("Name")), styles.Value.Render(r.Name)),
+		lipgloss.JoinHorizontal(lipgloss.Left, lipgloss.NewStyle().Width(10).Render(styles.Label.Render("Type")), styles.Value.Render(string(r.Type))),
+		lipgloss.JoinHorizontal(lipgloss.Left, lipgloss.NewStyle().Width(10).Render(styles.Label.Render("Content")), styles.Value.Render(r.Content)),
+		lipgloss.JoinHorizontal(lipgloss.Left, lipgloss.NewStyle().Width(10).Render(styles.Label.Render("TTL")), styles.Value.Render(fmt.Sprintf("%d", r.TTL))),
+	}
+
+	warning := styles.ErrorText.Render("This action cannot be undone.")
+
+	// Buttons
+	delBtn := "[ Delete ]"
+	canBtn := "[ Cancel ]"
+
+	if m.confirmIdx == 0 {
+		delBtn = lipgloss.NewStyle().Foreground(styles.White).Background(styles.Red).Render(delBtn)
+		canBtn = styles.MutedText.Render(canBtn)
+	} else {
+		delBtn = lipgloss.NewStyle().Foreground(styles.Red).Render(delBtn)
+		canBtn = lipgloss.NewStyle().Foreground(styles.White).Background(styles.Gray).Render(canBtn)
+	}
+
+	buttons := lipgloss.JoinHorizontal(lipgloss.Center, delBtn, "  ", canBtn)
+
+	cardContent := lipgloss.JoinVertical(lipgloss.Left,
+		title,
+		"",
+		strings.Join(fields, "\n"),
+		"",
+		warning,
+	)
+
+	// Make the card border red
+	cardStyle := styles.Card.Copy().BorderForeground(styles.Red)
+
+	return lipgloss.JoinVertical(lipgloss.Center, cardStyle.Render(cardContent), "", buttons)
+}
diff --git a/internal/tui/dns_record_edit.go b/internal/tui/dns_record_edit.go
new file mode 100644
index 0000000..5a6cf91
--- /dev/null
+++ b/internal/tui/dns_record_edit.go
@@ -0,0 +1,344 @@
+package tui
+
+import (
+	"fmt"
+	"strconv"
+	"strings"
+
+	"nathanbeddoewebdev/vpsm/internal/dns/domain"
+	"nathanbeddoewebdev/vpsm/internal/dns/services"
+	"nathanbeddoewebdev/vpsm/internal/tui/components"
+	"nathanbeddoewebdev/vpsm/internal/tui/styles"
+
+	"github.com/charmbracelet/bubbles/textinput"
+	tea "github.com/charmbracelet/bubbletea"
+	"github.com/charmbracelet/lipgloss"
+)
+
+type dnsRecordEditModel struct {
+	service      *services.Service
+	providerName string
+	domain       string
+	record       domain.Record
+	opts         domain.UpdateRecordOpts
+
+	step dnsCreateStep // Reuse the same steps as create
+
+	// Text inputs
+	inputs map[dnsCreateStep]textinput.Model
+
+	embedded bool
+	width    int
+	height   int
+}
+
+func newDNSRecordEditModel(svc *services.Service, providerName, domainName string, record domain.Record, embedded bool, width, height int) dnsRecordEditModel {
+	inputs := make(map[dnsCreateStep]textinput.Model)
+
+	// Name input
+	nameIn := textinput.New()
+	nameIn.Placeholder = "e.g. www (leave empty for root)"
+	nameIn.SetValue(record.Name)
+	inputs[dnsCreateStepName] = nameIn
+
+	// Content input
+	contentIn := textinput.New()
+	contentIn.Placeholder = "e.g. 1.2.3.4"
+	contentIn.SetValue(record.Content)
+	inputs[dnsCreateStepContent] = contentIn
+
+	// TTL input
+	ttlIn := textinput.New()
+	ttlIn.Placeholder = "e.g. 600"
+	if record.TTL > 0 {
+		ttlIn.SetValue(strconv.Itoa(record.TTL))
+	}
+	inputs[dnsCreateStepTTL] = ttlIn
+
+	// Priority input
+	prioIn := textinput.New()
+	prioIn.Placeholder = "e.g. 10"
+	if record.Priority > 0 {
+		prioIn.SetValue(strconv.Itoa(record.Priority))
+	}
+	inputs[dnsCreateStepPriority] = prioIn
+
+	// Notes input
+	notesIn := textinput.New()
+	notesIn.Placeholder = "Optional notes"
+	notesIn.SetValue(record.Notes)
+	inputs[dnsCreateStepNotes] = notesIn
+
+	opts := domain.UpdateRecordOpts{
+		Type: record.Type,
+	}
+
+	m := dnsRecordEditModel{
+		service:      svc,
+		providerName: providerName,
+		domain:       domainName,
+		record:       record,
+		opts:         opts,
+		step:         dnsCreateStepName, // Skip type step
+		inputs:       inputs,
+		embedded:     embedded,
+		width:        width,
+		height:       height,
+	}
+	m.focusInput()
+	return m
+}
+
+func (m dnsRecordEditModel) Init() tea.Cmd {
+	return nil
+}
+
+func (m dnsRecordEditModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
+	var cmds []tea.Cmd
+
+	switch msg := msg.(type) {
+	case tea.WindowSizeMsg:
+		m.width = msg.Width
+		m.height = msg.Height
+
+	case tea.KeyMsg:
+		switch msg.String() {
+		case "esc":
+			if m.step > dnsCreateStepName {
+				m.step--
+				// Skip priority if not MX or SRV
+				if m.step == dnsCreateStepPriority && m.opts.Type != "MX" && m.opts.Type != "SRV" {
+					m.step--
+				}
+				m.focusInput()
+				return m, nil
+			}
+			if m.embedded {
+				return m, func() tea.Msg { return dnsNavigateBackMsg{} }
+			}
+			return m, tea.Quit
+		case "ctrl+c":
+			return m, tea.Quit
+		case "enter":
+			// Process current step
+			switch m.step {
+			case dnsCreateStepName:
+				m.opts.Name = m.inputs[m.step].Value()
+				m.step++
+				m.focusInput()
+			case dnsCreateStepContent:
+				val := m.inputs[m.step].Value()
+				if val == "" {
+					return m, nil // Don't allow empty content
+				}
+				m.opts.Content = val
+				m.step++
+				m.focusInput()
+			case dnsCreateStepTTL:
+				val := m.inputs[m.step].Value()
+				if val != "" {
+					if ttl, err := strconv.Atoi(val); err == nil {
+						m.opts.TTL = ttl
+					}
+				}
+				m.step++
+				if m.opts.Type != "MX" && m.opts.Type != "SRV" {
+					m.step++ // skip priority
+				}
+				m.focusInput()
+			case dnsCreateStepPriority:
+				val := m.inputs[m.step].Value()
+				if val != "" {
+					if prio, err := strconv.Atoi(val); err == nil {
+						m.opts.Priority = prio
+					}
+				}
+				m.step++
+				m.focusInput()
+			case dnsCreateStepNotes:
+				val := m.inputs[m.step].Value()
+				m.opts.Notes = &val
+				m.step++ // Go to confirm
+			case dnsCreateStepConfirm:
+				if m.embedded {
+					return m, func() tea.Msg {
+						return dnsUpdateConfirmedMsg{domain: m.domain, id: m.record.ID, opts: m.opts}
+					}
+				}
+				return m, tea.Quit
+			}
+		}
+
+	}
+
+	// Route msg to current input if applicable
+	if m.step >= dnsCreateStepName && m.step <= dnsCreateStepNotes {
+		if in, ok := m.inputs[m.step]; ok {
+			var cmd tea.Cmd
+			in, cmd = in.Update(msg)
+			m.inputs[m.step] = in
+			cmds = append(cmds, cmd)
+		}
+	}
+
+	return m, tea.Batch(cmds...)
+}
+
+func (m *dnsRecordEditModel) focusInput() {
+	for k, in := range m.inputs {
+		if k == m.step {
+			in.Focus()
+		} else {
+			in.Blur()
+		}
+		m.inputs[k] = in
+	}
+}
+
+func (m dnsRecordEditModel) View() string {
+	header := components.Header(m.width, "dns > edit", m.providerName)
+
+	bindings := []components.KeyBinding{
+		{Key: "esc", Desc: "back"},
+	}
+	if m.step == dnsCreateStepConfirm {
+		bindings = append(bindings, components.KeyBinding{Key: "enter", Desc: "confirm"})
+	} else {
+		bindings = append(bindings, components.KeyBinding{Key: "enter", Desc: "next"})
+	}
+
+	footer := components.Footer(m.width, bindings)
+
+	headerH := lipgloss.Height(header)
+	footerH := lipgloss.Height(footer)
+	contentH := m.height - headerH - footerH
+	if contentH < 1 {
+		contentH = 1
+	}
+
+	var content string
+	switch m.step {
+	case dnsCreateStepName:
+		content = m.renderInputStep("Subdomain Name")
+	case dnsCreateStepContent:
+		content = m.renderInputStep(fmt.Sprintf("%s Content", m.opts.Type))
+	case dnsCreateStepTTL:
+		content = m.renderInputStep("TTL (seconds)")
+	case dnsCreateStepPriority:
+		content = m.renderInputStep("Priority")
+	case dnsCreateStepNotes:
+		content = m.renderInputStep("Notes")
+	case dnsCreateStepConfirm:
+		content = m.renderConfirmStep()
+	}
+
+	content = m.renderStepper() + "\n\n" + content
+
+	// Pad to height
+	lines := lipgloss.Height(content)
+	if lines < contentH {
+		content += strings.Repeat("\n", contentH-lines)
+	}
+
+	return lipgloss.JoinVertical(lipgloss.Left, header, content, footer)
+}
+
+func (m dnsRecordEditModel) renderStepper() string {
+	steps := []string{"Name", "Content", "TTL"}
+	if m.opts.Type == "MX" || m.opts.Type == "SRV" {
+		steps = append(steps, "Priority")
+	}
+	steps = append(steps, "Confirm")
+
+	logicalStep := int(m.step) - 1 // skip type
+	if m.step >= dnsCreateStepPriority && m.opts.Type != "MX" && m.opts.Type != "SRV" {
+		logicalStep--
+	}
+	if m.step >= dnsCreateStepNotes {
+		logicalStep--
+	}
+
+	var parts []string
+	for i, step := range steps {
+		if i == logicalStep {
+			parts = append(parts, styles.AccentText.Render(" "+step))
+		} else if i < logicalStep {
+			parts = append(parts, styles.SuccessText.Render(" ")+styles.MutedText.Render(step))
+		} else {
+			parts = append(parts, styles.MutedText.Render(" "+step))
+		}
+	}
+	return "  " + strings.Join(parts, "  ")
+}
+
+func (m dnsRecordEditModel) renderInputStep(title string) string {
+	in := m.inputs[m.step]
+
+	in.PromptStyle = styles.AccentText
+	in.TextStyle = styles.Value
+	in.PlaceholderStyle = styles.MutedText
+
+	if in.Focused() {
+		view := in.View()
+		box := styles.CardActive.Render(view)
+		return fmt.Sprintf("  %s\n\n%s", styles.Subtitle.Render(title+":"), "  "+box)
+	}
+	return fmt.Sprintf("  %s\n\n  %s", styles.Subtitle.Render(title+":"), in.View())
+}
+
+func (m dnsRecordEditModel) renderConfirmStep() string {
+	title := styles.Title.Render("Update DNS Record")
+
+	o := m.opts
+	r := m.record
+
+	ttlStr := strconv.Itoa(o.TTL)
+	if o.TTL == 0 {
+		ttlStr = "Default"
+	}
+
+	name := o.Name
+	if name == "" {
+		name = "(Root)"
+	}
+
+	// Helper to highlight changed fields
+	val := func(old string, newStr string) string {
+		if old != newStr && newStr != "" {
+			return styles.AccentText.Render(newStr)
+		}
+		return styles.Value.Render(old)
+	}
+
+	notesStr := r.Notes
+	if o.Notes != nil {
+		notesStr = *o.Notes
+	}
+
+	fields := []string{
+		lipgloss.JoinHorizontal(lipgloss.Left, lipgloss.NewStyle().Width(10).Render(styles.Label.Render("Domain")), styles.Value.Render(m.domain)),
+		lipgloss.JoinHorizontal(lipgloss.Left, lipgloss.NewStyle().Width(10).Render(styles.Label.Render("Type")), styles.Value.Render(string(o.Type))),
+		lipgloss.JoinHorizontal(lipgloss.Left, lipgloss.NewStyle().Width(10).Render(styles.Label.Render("Name")), val(r.Name, name)),
+		lipgloss.JoinHorizontal(lipgloss.Left, lipgloss.NewStyle().Width(10).Render(styles.Label.Render("Content")), val(r.Content, o.Content)),
+		lipgloss.JoinHorizontal(lipgloss.Left, lipgloss.NewStyle().Width(10).Render(styles.Label.Render("TTL")), val(strconv.Itoa(r.TTL), ttlStr)),
+	}
+
+	if r.Priority > 0 || o.Priority > 0 {
+		fields = append(fields, lipgloss.JoinHorizontal(lipgloss.Left, lipgloss.NewStyle().Width(10).Render(styles.Label.Render("Priority")), val(strconv.Itoa(r.Priority), strconv.Itoa(o.Priority))))
+	}
+	if r.Notes != "" || (o.Notes != nil && *o.Notes != "") {
+		fields = append(fields, lipgloss.JoinHorizontal(lipgloss.Left, lipgloss.NewStyle().Width(10).Render(styles.Label.Render("Notes")), val(r.Notes, notesStr)))
+	}
+
+	cardContent := lipgloss.JoinVertical(lipgloss.Left,
+		title,
+		"",
+		strings.Join(fields, "\n"),
+	)
+
+	return lipgloss.JoinVertical(lipgloss.Center,
+		styles.CardActive.Render(cardContent),
+		"",
+		"  Press Enter to Update",
+	)
+}
diff --git a/internal/tui/dns_record_list.go b/internal/tui/dns_record_list.go
new file mode 100644
index 0000000..d24c54f
--- /dev/null
+++ b/internal/tui/dns_record_list.go
@@ -0,0 +1,341 @@
+package tui
+
+import (
+	"context"
+	"fmt"
+	"strings"
+
+	"nathanbeddoewebdev/vpsm/internal/dns/domain"
+	"nathanbeddoewebdev/vpsm/internal/dns/services"
+	"nathanbeddoewebdev/vpsm/internal/tui/components"
+	"nathanbeddoewebdev/vpsm/internal/tui/styles"
+
+	"github.com/charmbracelet/bubbles/spinner"
+	tea "github.com/charmbracelet/bubbletea"
+	"github.com/charmbracelet/lipgloss"
+)
+
+// --- Messages ---
+
+type dnsRecordsLoadedMsg struct {
+	records []domain.Record
+}
+
+type dnsRecordsErrorMsg struct {
+	err error
+}
+
+// --- Record list model ---
+
+type dnsRecordListModel struct {
+	service      *services.Service
+	providerName string
+	domain       string
+
+	records   []domain.Record
+	filtered  []domain.Record
+	cursor    int
+	listStart int // for scrolling
+
+	typeFilter string // e.g. "A", "CNAME", "" for all
+	typeTypes  []string
+
+	width  int
+	height int
+
+	loading          bool
+	spinner          spinner.Model
+	err              error
+	status           string
+	statusIsError    bool
+	persistentStatus string
+
+	embedded bool
+}
+
+func newDNSRecordListModel(svc *services.Service, providerName, domainName string, embedded bool, width, height int) dnsRecordListModel {
+	s := spinner.New()
+	s.Spinner = spinner.Dot
+	s.Style = lipgloss.NewStyle().Foreground(styles.Blue)
+
+	return dnsRecordListModel{
+		service:      svc,
+		providerName: providerName,
+		domain:       domainName,
+		typeTypes:    []string{"", "A", "AAAA", "CNAME", "MX", "TXT"},
+		typeFilter:   "",
+		embedded:     embedded,
+		width:        width,
+		height:       height,
+		loading:      true,
+		spinner:      s,
+	}
+}
+
+func (m dnsRecordListModel) Init() tea.Cmd {
+	return tea.Batch(m.spinner.Tick, m.loadRecordsCmd())
+}
+
+func (m dnsRecordListModel) loadRecordsCmd() tea.Cmd {
+	return func() tea.Msg {
+		records, err := m.service.ListRecords(context.Background(), m.domain)
+		if err != nil {
+			return dnsRecordsErrorMsg{err}
+		}
+		return dnsRecordsLoadedMsg{records}
+	}
+}
+
+func (m *dnsRecordListModel) applyFilter() {
+	m.filtered = make([]domain.Record, 0)
+	for _, r := range m.records {
+		if m.typeFilter == "" || strings.EqualFold(string(r.Type), m.typeFilter) {
+			m.filtered = append(m.filtered, r)
+		}
+	}
+	if m.cursor >= len(m.filtered) {
+		m.cursor = len(m.filtered) - 1
+		if m.cursor < 0 {
+			m.cursor = 0
+		}
+	}
+	if m.listStart >= len(m.filtered) {
+		m.listStart = 0
+	}
+}
+
+func (m dnsRecordListModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
+	var cmds []tea.Cmd
+
+	switch msg := msg.(type) {
+	case tea.WindowSizeMsg:
+		m.width = msg.Width
+		m.height = msg.Height
+
+	case tea.KeyMsg:
+		switch msg.String() {
+		case "esc", "backspace":
+			if m.embedded {
+				return m, func() tea.Msg { return dnsNavigateBackMsg{} }
+			}
+			return m, tea.Quit
+		case "q":
+			if !m.embedded {
+				return m, tea.Quit
+			}
+		case "up", "k":
+			if m.cursor > 0 {
+				m.cursor--
+			}
+		case "down", "j":
+			if m.cursor < len(m.filtered)-1 {
+				m.cursor++
+			}
+		case "f":
+			// Cycle type filter
+			idx := 0
+			for i, t := range m.typeTypes {
+				if t == m.typeFilter {
+					idx = i
+					break
+				}
+			}
+			idx = (idx + 1) % len(m.typeTypes)
+			m.typeFilter = m.typeTypes[idx]
+			m.applyFilter()
+		case "r":
+			m.loading = true
+			m.err = nil
+			return m, m.loadRecordsCmd()
+		case "enter":
+			if len(m.filtered) > 0 {
+				rec := m.filtered[m.cursor]
+				if m.embedded {
+					return m, func() tea.Msg { return dnsNavigateToRecordShowMsg{record: rec, domain: m.domain} }
+				}
+			}
+		case "c":
+			if m.embedded {
+				return m, func() tea.Msg { return dnsNavigateToRecordCreateMsg{domain: m.domain} }
+			}
+		case "d":
+			if len(m.filtered) > 0 {
+				rec := m.filtered[m.cursor]
+				if m.embedded {
+					return m, func() tea.Msg { return dnsNavigateToRecordDeleteMsg{record: rec, domain: m.domain} }
+				}
+			}
+		case "e":
+			if len(m.filtered) > 0 {
+				rec := m.filtered[m.cursor]
+				if m.embedded {
+					return m, func() tea.Msg { return dnsNavigateToRecordEditMsg{record: rec, domain: m.domain} }
+				}
+			}
+		}
+
+	case dnsRecordsLoadedMsg:
+		m.loading = false
+		m.records = msg.records
+		m.applyFilter()
+
+		status := fmt.Sprintf("Loaded %d records.", len(m.records))
+		if m.persistentStatus != "" {
+			status = m.persistentStatus + " | " + status
+			// We keep persistentStatus around until the user does something else
+		}
+		m.status = status
+
+	case dnsRecordsErrorMsg:
+		m.loading = false
+		m.err = msg.err
+		m.status = msg.err.Error()
+		m.statusIsError = true
+
+	case spinner.TickMsg:
+		if m.loading {
+			var cmd tea.Cmd
+			m.spinner, cmd = m.spinner.Update(msg)
+			cmds = append(cmds, cmd)
+		}
+	}
+
+	return m, tea.Batch(cmds...)
+}
+
+func (m dnsRecordListModel) View() string {
+	header := components.Header(m.width, "dns > "+m.domain, m.providerName)
+
+	bindings := []components.KeyBinding{
+		{Key: "j/k", Desc: "nav"},
+		{Key: "enter", Desc: "show"},
+		{Key: "c", Desc: "create"},
+		{Key: "d", Desc: "delete"},
+		{Key: "e", Desc: "edit"},
+		{Key: "f", Desc: "filter"},
+		{Key: "esc", Desc: "back"},
+	}
+	if !m.embedded {
+		bindings = append(bindings, components.KeyBinding{Key: "q", Desc: "quit"})
+	}
+	footer := components.Footer(m.width, bindings)
+
+	statusBar := components.StatusBar(m.width, m.status, m.statusIsError)
+
+	headerH := lipgloss.Height(header)
+	footerH := lipgloss.Height(footer)
+	statusH := lipgloss.Height(statusBar)
+	contentH := m.height - headerH - footerH - statusH
+	if contentH < 1 {
+		contentH = 1
+	}
+
+	var content string
+	if m.loading {
+		content = fmt.Sprintf("\n  %s Loading records...", m.spinner.View())
+	} else if m.err != nil {
+		content = fmt.Sprintf("\n  %s", styles.ErrorText.Render(m.err.Error()))
+	} else if len(m.records) == 0 {
+		content = "\n  No records found for this domain."
+	} else {
+		content = m.renderFilterBar() + "\n" + m.renderTable(contentH-2)
+	}
+
+	lines := lipgloss.Height(content)
+	if lines < contentH {
+		content += lipgloss.NewStyle().Height(contentH - lines).Render("")
+	}
+
+	return lipgloss.JoinVertical(lipgloss.Left, header, content, statusBar, footer)
+}
+
+func (m dnsRecordListModel) renderFilterBar() string {
+	var parts []string
+	parts = append(parts, "  Filter: ")
+
+	for _, t := range m.typeTypes {
+		label := t
+		if t == "" {
+			label = "All"
+		}
+
+		if t == m.typeFilter {
+			parts = append(parts, fmt.Sprintf("[%s]", styles.AccentText.Render(label)))
+		} else {
+			parts = append(parts, fmt.Sprintf(" %s ", styles.MutedText.Render(label)))
+		}
+	}
+
+	return strings.Join(parts, "")
+}
+
+func (m dnsRecordListModel) renderTable(height int) string {
+	if len(m.filtered) == 0 {
+		return "\n  No records match current filter."
+	}
+
+	cols := []int{30, 8, 40, 8}
+
+	header := styles.TableHeader.Render(
+		fmt.Sprintf("  %-*s %-*s %-*s %-*s",
+			cols[0], "NAME",
+			cols[1], "TYPE",
+			cols[2], "CONTENT",
+			cols[3], "TTL",
+		),
+	)
+
+	var rows []string
+	rows = append(rows, header)
+
+	if m.cursor < m.listStart {
+		m.listStart = m.cursor
+	} else if m.cursor >= m.listStart+(height-1) {
+		m.listStart = m.cursor - (height - 2)
+	}
+
+	end := m.listStart + height - 1
+	if end > len(m.filtered) {
+		end = len(m.filtered)
+	}
+
+	for i := m.listStart; i < end; i++ {
+		r := m.filtered[i]
+
+		cursor := " "
+		rowStyle := styles.TableCell
+		if i == m.cursor {
+			cursor = styles.AccentText.Render(">")
+			rowStyle = styles.TableSelectedRow
+		}
+
+		// Truncate content if too long
+		contentStr := r.Content
+		if len(contentStr) > cols[2]-2 {
+			contentStr = contentStr[:cols[2]-5] + "..."
+		}
+
+		typeColor := styles.Value
+		switch r.Type {
+		case "A", "AAAA":
+			typeColor = lipgloss.NewStyle().Foreground(styles.Green)
+		case "CNAME":
+			typeColor = lipgloss.NewStyle().Foreground(styles.Yellow)
+		case "MX":
+			typeColor = lipgloss.NewStyle().Foreground(styles.Blue)
+		case "TXT":
+			typeColor = styles.MutedText
+		}
+
+		row := fmt.Sprintf("%s %-*s %-*s %-*s %-*d",
+			cursor,
+			cols[0], r.Name,
+			cols[1], typeColor.Render(string(r.Type)),
+			cols[2], contentStr,
+			cols[3], r.TTL,
+		)
+		rows = append(rows, rowStyle.Render(row))
+	}
+
+	return lipgloss.JoinVertical(lipgloss.Left, rows...)
+}
diff --git a/internal/tui/dns_record_show.go b/internal/tui/dns_record_show.go
new file mode 100644
index 0000000..30291a7
--- /dev/null
+++ b/internal/tui/dns_record_show.go
@@ -0,0 +1,158 @@
+package tui
+
+import (
+	"fmt"
+	"strconv"
+
+	"nathanbeddoewebdev/vpsm/internal/dns/domain"
+	"nathanbeddoewebdev/vpsm/internal/tui/components"
+	"nathanbeddoewebdev/vpsm/internal/tui/styles"
+
+	tea "github.com/charmbracelet/bubbletea"
+	"github.com/charmbracelet/lipgloss"
+)
+
+type dnsRecordShowModel struct {
+	record       domain.Record
+	domain       string
+	providerName string
+	embedded     bool
+	width        int
+	height       int
+}
+
+func newDNSRecordShowModel(record domain.Record, domainName string, providerName string, embedded bool, width, height int) dnsRecordShowModel {
+	return dnsRecordShowModel{
+		record:       record,
+		domain:       domainName,
+		providerName: providerName,
+		embedded:     embedded,
+		width:        width,
+		height:       height,
+	}
+}
+
+func (m dnsRecordShowModel) Init() tea.Cmd {
+	return nil
+}
+
+func (m dnsRecordShowModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
+	switch msg := msg.(type) {
+	case tea.WindowSizeMsg:
+		m.width = msg.Width
+		m.height = msg.Height
+
+	case tea.KeyMsg:
+		switch msg.String() {
+		case "esc", "backspace", "left", "h":
+			if m.embedded {
+				return m, func() tea.Msg { return dnsNavigateBackMsg{} }
+			}
+			return m, tea.Quit
+		case "q":
+			if !m.embedded {
+				return m, tea.Quit
+			}
+		case "e":
+			if m.embedded {
+				return m, func() tea.Msg { return dnsNavigateToRecordEditMsg{record: m.record, domain: m.domain} }
+			}
+		case "d":
+			if m.embedded {
+				return m, func() tea.Msg { return dnsNavigateToRecordDeleteMsg{record: m.record, domain: m.domain} }
+			}
+		}
+	}
+
+	return m, nil
+}
+
+func (m dnsRecordShowModel) View() string {
+	breadcrumb := fmt.Sprintf("dns > %s > %s", m.domain, m.record.Name)
+	header := components.Header(m.width, breadcrumb, m.providerName)
+
+	bindings := []components.KeyBinding{
+		{Key: "e", Desc: "edit"},
+		{Key: "d", Desc: "delete"},
+		{Key: "esc", Desc: "back"},
+	}
+	if !m.embedded {
+		bindings = append(bindings, components.KeyBinding{Key: "q", Desc: "quit"})
+	}
+	footer := components.Footer(m.width, bindings)
+
+	headerH := lipgloss.Height(header)
+	footerH := lipgloss.Height(footer)
+	contentH := m.height - headerH - footerH
+	if contentH < 1 {
+		contentH = 1
+	}
+
+	content := m.renderCard()
+
+	// Center horizontally and vertically
+	content = lipgloss.Place(m.width, contentH, lipgloss.Center, lipgloss.Center, content)
+
+	return lipgloss.JoinVertical(lipgloss.Left, header, content, footer)
+}
+
+func (m dnsRecordShowModel) renderCard() string {
+	r := m.record
+
+	// Header row: Name + Type badge
+	typeColor := styles.Value
+	switch r.Type {
+	case "A", "AAAA":
+		typeColor = lipgloss.NewStyle().Foreground(styles.Green)
+	case "CNAME":
+		typeColor = lipgloss.NewStyle().Foreground(styles.Yellow)
+	case "MX":
+		typeColor = lipgloss.NewStyle().Foreground(styles.Blue)
+	case "TXT":
+		typeColor = styles.MutedText
+	}
+
+	titleRow := lipgloss.JoinHorizontal(lipgloss.Center,
+		styles.Title.Render(r.Name),
+		"  ",
+		typeColor.Render(string(r.Type)),
+	)
+
+	// Detail grid
+	fields := []struct {
+		label string
+		val   string
+	}{
+		{"ID", r.ID},
+		{"Name", r.Name},
+		{"Type", string(r.Type)},
+		{"Content", r.Content},
+		{"TTL", strconv.Itoa(r.TTL)},
+		{"Priority", ""},
+	}
+
+	if r.Priority > 0 {
+		fields[5].val = strconv.Itoa(r.Priority)
+	}
+
+	if r.Notes != "" {
+		fields = append(fields, struct {
+			label string
+			val   string
+		}{"Notes", r.Notes})
+	}
+
+	var gridRows []string
+	gridRows = append(gridRows, titleRow, "") // Title + empty line
+
+	for _, f := range fields {
+		row := lipgloss.JoinHorizontal(lipgloss.Left,
+			lipgloss.NewStyle().Width(12).Render(styles.Label.Render(f.label)),
+			styles.Value.Render(f.val),
+		)
+		gridRows = append(gridRows, row)
+	}
+
+	content := lipgloss.JoinVertical(lipgloss.Left, gridRows...)
+	return styles.Card.Render(content)
+}
diff --git a/internal/tui/ops_overlay.go b/internal/tui/ops_overlay.go
index 9ed1e17..9931cbe 100644
--- a/internal/tui/ops_overlay.go
+++ b/internal/tui/ops_overlay.go
@@ -702,10 +702,7 @@ func (o opsOverlay) View(width, height int) string {
 	content := strings.Join(lines, "\n")
 
 	// Build card.
-	cardWidth := overlayMaxWidth
-	if cardWidth > width-4 {
-		cardWidth = width - 4
-	}
+	cardWidth := min(overlayMaxWidth, width-4)
 	if cardWidth < overlayMinWidth {
 		cardWidth = overlayMinWidth
 	}
@@ -772,14 +769,8 @@ func composeOverlay(base string, overlay string, width, height int) string {
 
 	// Position: bottom-right with 2 rows above the bottom (above footer)
 	// and 1 col margin from the right edge.
-	startRow := height - overlayH - 2
-	if startRow < 1 {
-		startRow = 1
-	}
-	startCol := width - overlayW - 1
-	if startCol < 0 {
-		startCol = 0
-	}
+	startRow := max(height-overlayH-2, 1)
+	startCol := max(width-overlayW-1, 0)
 
 	for i, oLine := range overlayLines {
 		row := startRow + i
@@ -801,10 +792,7 @@ func composeOverlay(base string, overlay string, width, height int) string {
 
 		// Overlay line + right padding to fill remaining width.
 		oLineW := lipgloss.Width(oLine)
-		rightPad := width - startCol - oLineW
-		if rightPad < 0 {
-			rightPad = 0
-		}
+		rightPad := max(width-startCol-oLineW, 0)
 
 		baseLines[row] = left + oLine + strings.Repeat(" ", rightPad)
 	}
diff --git a/internal/tui/server_app.go b/internal/tui/server_app.go
index 9d73ccf..6a39e1d 100644
--- a/internal/tui/server_app.go
+++ b/internal/tui/server_app.go
@@ -793,10 +793,7 @@ func (m serverAppModel) renderAction() string {
 
 	headerH := lipgloss.Height(header)
 	footerH := lipgloss.Height(footer)
-	contentH := m.height - headerH - footerH
-	if contentH < 1 {
-		contentH = 1
-	}
+	contentH := max(m.height-headerH-footerH, 1)
 
 	var content string
 	if m.actionStatus != "" {
diff --git a/internal/tui/server_create.go b/internal/tui/server_create.go
index 6ac6b4c..b9b4ea4 100644
--- a/internal/tui/server_create.go
+++ b/internal/tui/server_create.go
@@ -632,10 +632,7 @@ func (m serverCreateModel) View() string {
 
 	headerH := lipgloss.Height(header)
 	footerH := lipgloss.Height(footer)
-	contentH := m.height - headerH - footerH
-	if contentH < 1 {
-		contentH = 1
-	}
+	contentH := max(m.height-headerH-footerH, 1)
 
 	content := m.renderContent(contentH)
 
@@ -749,10 +746,7 @@ func (m serverCreateModel) renderListStep(title string, items []createItem, curs
 		start = cursor - maxVisible + 1
 	}
 
-	end := start + maxVisible
-	if end > len(items) {
-		end = len(items)
-	}
+	end := min(start+maxVisible, len(items))
 
 	rows := make([]string, 0, end-start)
 	for i := start; i < end; i++ {
@@ -815,10 +809,7 @@ func (m serverCreateModel) renderSSHKeysStep(maxVisible int) string {
 		m.sshStart = m.sshIdx - maxVisible + 1
 	}
 
-	end := m.sshStart + maxVisible
-	if end > len(m.sshKeys) {
-		end = len(m.sshKeys)
-	}
+	end := min(m.sshStart+maxVisible, len(m.sshKeys))
 
 	rows := make([]string, 0, end-m.sshStart)
 	for i := m.sshStart; i < end; i++ {
diff --git a/internal/tui/server_delete.go b/internal/tui/server_delete.go
index 0c638f1..e11a497 100644
--- a/internal/tui/server_delete.go
+++ b/internal/tui/server_delete.go
@@ -292,10 +292,7 @@ func (m serverDeleteModel) View() string {
 
 	headerH := lipgloss.Height(header)
 	footerH := lipgloss.Height(footer)
-	contentH := m.height - headerH - footerH
-	if contentH < 1 {
-		contentH = 1
-	}
+	contentH := max(m.height-headerH-footerH, 1)
 
 	content := m.renderContent(contentH)
 
@@ -343,24 +340,15 @@ func (m serverDeleteModel) renderSelectPhase(height int) string {
 
 	title := styles.Title.Render("Select a server to delete")
 
-	maxVisible := height - 4
-	if maxVisible < 3 {
-		maxVisible = 3
-	}
+	maxVisible := max(height-4, 3)
 
 	// Scrolling.
-	start := m.listStart
-	if m.cursor < start {
-		start = m.cursor
-	}
+	start := min(m.cursor, m.listStart)
 	if m.cursor >= start+maxVisible {
 		start = m.cursor - maxVisible + 1
 	}
 
-	end := start + maxVisible
-	if end > len(m.servers) {
-		end = len(m.servers)
-	}
+	end := min(start+maxVisible, len(m.servers))
 
 	rows := make([]string, 0, end-start)
 	for i := start; i < end; i++ {
diff --git a/internal/tui/server_list.go b/internal/tui/server_list.go
index 27a4c17..d0ac7c4 100644
--- a/internal/tui/server_list.go
+++ b/internal/tui/server_list.go
@@ -354,10 +354,7 @@ func (m serverListModel) View() string {
 	headerH := lipgloss.Height(header)
 	footerH := lipgloss.Height(footer)
 	statusH := lipgloss.Height(statusBar)
-	contentH := m.height - headerH - footerH - statusH
-	if contentH < 1 {
-		contentH = 1
-	}
+	contentH := max(m.height-headerH-footerH-statusH, 1)
 
 	content := m.renderContent(contentH)
 
@@ -463,10 +460,9 @@ func (m serverListModel) renderTable(height int) string {
 	sep := styles.MutedText.Render(strings.Repeat("", available))
 
 	// Render data rows.
-	visibleRows := height - 3 // header + sep + bottom padding
-	if visibleRows < 1 {
-		visibleRows = 1
-	}
+	visibleRows := max(
+		// header + sep + bottom padding
+		height-3, 1)
 
 	// Scrolling: keep cursor visible.
 	startIdx := 0
@@ -476,10 +472,7 @@ func (m serverListModel) renderTable(height int) string {
 	endIdx := startIdx + visibleRows
 	if endIdx > len(m.servers) {
 		endIdx = len(m.servers)
-		startIdx = endIdx - visibleRows
-		if startIdx < 0 {
-			startIdx = 0
-		}
+		startIdx = max(endIdx-visibleRows, 0)
 	}
 
 	rows := make([]string, 0, visibleRows)
diff --git a/internal/tui/server_show.go b/internal/tui/server_show.go
index 6eb18f8..cbf749f 100644
--- a/internal/tui/server_show.go
+++ b/internal/tui/server_show.go
@@ -634,10 +634,7 @@ func (m serverShowModel) View() string {
 	headerH := lipgloss.Height(header)
 	footerH := lipgloss.Height(footer)
 	statusH := lipgloss.Height(statusBar)
-	contentH := m.height - headerH - footerH - statusH
-	if contentH < 1 {
-		contentH = 1
-	}
+	contentH := max(m.height-headerH-footerH-statusH, 1)
 
 	content := m.renderContent(contentH)
 
@@ -714,24 +711,15 @@ func (m serverShowModel) renderSelectPhase(height int) string {
 
 	title := styles.Title.Render("Select a server")
 
-	maxVisible := height - 4
-	if maxVisible < 3 {
-		maxVisible = 3
-	}
+	maxVisible := max(height-4, 3)
 
 	// Scrolling.
-	start := m.listStart
-	if m.cursor < start {
-		start = m.cursor
-	}
+	start := min(m.cursor, m.listStart)
 	if m.cursor >= start+maxVisible {
 		start = m.cursor - maxVisible + 1
 	}
 
-	end := start + maxVisible
-	if end > len(m.servers) {
-		end = len(m.servers)
-	}
+	end := min(start+maxVisible, len(m.servers))
 
 	rows := make([]string, 0, end-start)
 	for i := start; i < end; i++ {
@@ -792,31 +780,21 @@ func (m serverShowModel) renderDetail() string {
 	const columnGap = 2
 
 	// Usable width after horizontal padding on both sides.
-	usableWidth := m.width - (hPad * 2)
-	if usableWidth < 60 {
-		usableWidth = 60
-	}
+	usableWidth := max(m.width-(hPad*2), 60)
 
 	// Left column: ~45% of width, giving room for long values.
-	leftWidth := usableWidth * 45 / 100
-	if leftWidth > 52 {
-		leftWidth = 52
-	}
+	leftWidth := min(usableWidth*45/100, 52)
 	if leftWidth < 34 {
 		leftWidth = 34
 	}
 
 	// Right column gets the rest. Needs enough room for Y-axis labels + chart.
-	rightWidth := usableWidth - leftWidth - columnGap
-	if rightWidth < 36 {
-		rightWidth = 36
-	}
+	rightWidth := max(usableWidth-leftWidth-columnGap, 36)
 
 	labelWidth := 14
-	valueWidth := leftWidth - labelWidth - 8 // padding + border
-	if valueWidth < 6 {
-		valueWidth = 6
-	}
+	valueWidth := max(
+		// padding + border
+		leftWidth-labelWidth-8, 6)
 
 	renderField := func(label, value string) string {
 		l := styles.Label.Width(labelWidth).Render(label)
@@ -915,10 +893,7 @@ func (m serverShowModel) renderMetricsSection(cardWidth int, sectionStyle lipglo
 
 	// Chart width = card inner content width.
 	// Card has Border(1 each side) + Padding(2 each side) = 6 horizontal overhead.
-	chartWidth := cardWidth - 6
-	if chartWidth < 20 {
-		chartWidth = 20
-	}
+	chartWidth := max(cardWidth-6, 20)
 
 	var charts []string
 
diff --git a/internal/tui/server_ssh.go b/internal/tui/server_ssh.go
index 2b7b7c0..ca85c01 100644
--- a/internal/tui/server_ssh.go
+++ b/internal/tui/server_ssh.go
@@ -134,10 +134,7 @@ func (m serverSSHModel) View() string {
 
 	headerH := lipgloss.Height(header)
 	footerH := lipgloss.Height(footer)
-	contentH := m.height - headerH - footerH
-	if contentH < 1 {
-		contentH = 1
-	}
+	contentH := max(m.height-headerH-footerH, 1)
 
 	content := m.renderContent(contentH)
 
diff --git a/internal/tui/show.go b/internal/tui/show.go
index a51c504..665c7b9 100644
--- a/internal/tui/show.go
+++ b/internal/tui/show.go
@@ -55,10 +55,7 @@ func ShowServerForm(provider domain.Provider) (*domain.Server, error) {
 	var selectedID string
 	serverOpts := buildServerOptions(servers)
 
-	height := len(serverOpts)
-	if height < 5 {
-		height = 5
-	}
+	height := max(len(serverOpts), 5)
 	if height > 12 {
 		height = 12
 	}
diff --git a/internal/tui/ssh_key_add.go b/internal/tui/ssh_key_add.go
index 72f0137..e0414bf 100644
--- a/internal/tui/ssh_key_add.go
+++ b/internal/tui/ssh_key_add.go
@@ -282,10 +282,7 @@ func (m sshKeyAddModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
 	case tea.WindowSizeMsg:
 		m.width = msg.Width
 		m.height = msg.Height
-		available := msg.Width - 10
-		if available < 20 {
-			available = 20
-		}
+		available := max(msg.Width-10, 20)
 		m.pathInput.Width = minInt(60, available)
 		m.keyInput.Width = minInt(70, available)
 		m.nameInput.Width = minInt(40, available)
@@ -511,10 +508,7 @@ func (m sshKeyAddModel) View() string {
 
 	headerH := lipgloss.Height(header)
 	footerH := lipgloss.Height(footer)
-	contentH := m.height - headerH - footerH
-	if contentH < 1 {
-		contentH = 1
-	}
+	contentH := max(m.height-headerH-footerH, 1)
 
 	content := m.renderContent(contentH)
 	return lipgloss.JoinVertical(lipgloss.Left, header, content, footer)
